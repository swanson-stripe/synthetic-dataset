<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Stripe Dashboard Prototype - Multi-Persona</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: white;
            color: #1e293b;
            line-height: 1.6;
        }
        
        .prototype-header {
            background: white;
            padding: 1rem 2rem;
            display: flex;
            justify-content: flex-start;
            align-items: center;
        }
        
        /* Persona Selector Styles */
        .persona-selector-container {
            position: relative;
        }
        
        .persona-selector-button {
            display: flex;
            align-items: center;
            padding: 8px 12px;
            background: white;
            border: 1px solid #e1e5e9;
            border-radius: 6px;
            cursor: pointer;
            transition: all 0.15s ease;
            width: 260px;
            box-sizing: border-box;
        }
        
        .persona-selector-button:hover {
            border-color: #c6c6c6;
            background: #f8f9fa;
        }
        
        .persona-selector-button.open {
            border-color: #666;
        }
        
        .persona-logo {
            width: 32px;
            height: 32px;
            border-radius: 6px;
            object-fit: cover;
            flex-shrink: 0;
            margin-right: 12px;
        }
        
        .persona-selector-text {
            flex: 1;
            text-align: center;
            min-width: 0;
        }
        
        .persona-name {
            font-size: 15px;
            font-weight: 500;
            color: #1a1a1a;
            margin: 0;
            line-height: 1.2;
        }
        
        .persona-description {
            display: none;
        }
        
        .dropdown-arrow {
            width: 16px;
            height: 16px;
            color: #666;
            transition: transform 0.15s ease;
            margin-left: 12px;
            flex-shrink: 0;
        }
        
        .persona-selector-button.open .dropdown-arrow {
            transform: rotate(180deg);
        }
        
        .dropdown-arrow.open {
            transform: rotate(180deg);
        }
        
        /* Popover Styles */
        .persona-popover {
            position: absolute;
            top: 100%;
            left: 0;
            right: 0;
            background: white;
            border: 1px solid #e5e7eb;
            border-radius: 8px;
            box-shadow: 0 10px 25px rgba(0, 0, 0, 0.1);
            z-index: 1000;
            margin-top: 4px;
            padding: 1rem;
            display: none;
        }
        
        .persona-popover.show {
            display: block;
        }
        
        .popover-header {
            display: flex;
            align-items: center;
            gap: 0.75rem;
            margin-bottom: 1rem;
        }
        
        .popover-persona-logo {
            width: 32px;
            height: 32px;
            border-radius: 6px;
        }
        
        .popover-persona-info h3 {
            font-size: 1rem;
            font-weight: 600;
            color: #111827;
            margin: 0;
        }
        
        .popover-persona-info p {
            font-size: 0.875rem;
            color: #6b7280;
            margin: 0;
        }
        
        .stage-section {
            margin-bottom: 1rem;
        }
        
        .stage-label {
            font-size: 0.875rem;
            font-weight: 500;
            color: #374151;
            margin-bottom: 0.5rem;
        }
        
        .stage-options {
            display: flex;
            gap: 0.5rem;
        }
        
        .stage-option {
            padding: 0.5rem 1rem;
            background: #f9fafb;
            border: 1px solid #e5e7eb;
            border-radius: 6px;
            cursor: pointer;
            font-size: 0.875rem;
            color: #374151;
            transition: all 0.2s ease;
        }
        
        .stage-option:hover {
            background: #f3f4f6;
        }
        
        .stage-option.selected {
            background: #111827;
            color: white;
            border-color: #111827;
        }
        
        .change-persona-btn {
            display: inline-block;
            color: #6366f1;
            text-decoration: underline;
            font-size: 0.875rem;
            cursor: pointer;
            border: none;
            background: none;
            padding: 0;
            margin-top: 0.5rem;
        }
        
        .change-persona-btn:hover {
            color: #4f46e5;
        }
        
        /* Modal Styles */
        .persona-modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.5);
            z-index: 2000;
            align-items: center;
            justify-content: center;
        }
        
        .persona-modal.show {
            display: flex;
        }
        
        .modal-content {
            background: white;
            border-radius: 12px;
            padding: 2rem;
            max-width: 800px;
            width: 90%;
            max-height: 80vh;
            overflow-y: auto;
        }
        
        .modal-header {
            margin-bottom: 1.5rem;
        }
        
        .modal-title {
            font-size: 1.25rem;
            font-weight: 600;
            color: #111827;
            margin-bottom: 0.5rem;
        }
        
        .modal-subtitle {
            font-size: 0.875rem;
            color: #6b7280;
        }
        
        .personas-grid {
            display: grid;
            grid-template-columns: 1fr;
            gap: 0.75rem;
            margin-bottom: 2rem;
        }
        
        .persona-option {
            display: flex;
            align-items: center;
            gap: 1rem;
            padding: 1rem;
            border: 1px solid #e5e7eb;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.2s ease;
        }
        
        .persona-option:hover {
            border-color: #6366f1;
            background: #f8fafc;
        }
        
        .persona-option.selected {
            border-color: #6366f1;
            background: #f0f4ff;
        }
        
        .persona-option-logo {
            width: 40px;
            height: 40px;
            border-radius: 8px;
            flex-shrink: 0;
        }
        
        .persona-option-info {
            flex: 1;
        }
        
        .persona-option-name {
            font-size: 1rem;
            font-weight: 600;
            color: #111827;
            margin-bottom: 0.25rem;
        }
        
        .persona-option-description {
            font-size: 0.875rem;
            color: #6b7280;
            margin-bottom: 0.5rem;
        }
        
        .stripe-products {
            display: flex;
            gap: 0.375rem;
            flex-wrap: wrap;
        }
        
        .stripe-product-badge {
            padding: 0.25rem 0.5rem;
            background: #f1f5f9;
            color: #475569;
            font-size: 0.75rem;
            font-weight: 500;
            border-radius: 4px;
        }
        
        .modal-footer {
            display: flex;
            justify-content: flex-end;
            gap: 0.75rem;
            border-top: 1px solid #e5e7eb;
            padding-top: 1.5rem;
        }
        
        .btn {
            padding: 0.75rem 1.5rem;
            border-radius: 6px;
            font-size: 0.875rem;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.2s ease;
            border: none;
        }
        
        .btn-secondary {
            background: #f9fafb;
            color: #374151;
            border: 1px solid #e5e7eb;
        }
        
        .btn-secondary:hover {
            background: #f3f4f6;
        }
        
        .btn-primary {
            background: #6366f1;
            color: white;
        }
        
        .btn-primary:hover {
            background: #4f46e5;
        }
        
        .prototype-main {
            padding: 2rem;
            max-width: 1200px;
            margin: 0 auto;
        }
        
        .metrics-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 1.5rem;
            margin-bottom: 2rem;
        }
        
        .metric-card {
            padding: 1.5rem;
        }
        
        .metric-label {
            font-size: 0.875rem;
            color: #64748b;
            margin-bottom: 0.5rem;
        }
        
        .metric-value {
            font-size: 2rem;
            font-weight: 700;
            color: #0f172a;
        }
        
        .data-section {
            margin-bottom: 2rem;
            overflow: hidden;
        }
        
        .data-section-header {
            padding: 1rem 1.5rem;
        }
        
        .data-section-title {
            font-size: 1.125rem;
            font-weight: 600;
        }
        
        .data-table {
            width: 100%;
            border-collapse: collapse;
        }
        
        .data-table th {
            padding: 0.75rem 1.5rem;
            text-align: left;
            font-weight: 500;
            color: #374151;
        }
        
        .data-table td {
            padding: 0.75rem 1.5rem;
        }
        
        .status-badge {
            display: inline-block;
            padding: 0.25rem 0.5rem;
            border-radius: 4px;
            font-size: 0.75rem;
            font-weight: 500;
        }
        
        .status-succeeded {
            background: #dcfce7;
            color: #166534;
        }
        
        .status-failed {
            background: #fecaca;
            color: #991b1b;
        }
        
        .loading-state {
            display: none;
            text-align: center;
            padding: 2rem;
            color: #64748b;
        }
        
        .loading-state.active {
            display: block;
        }
        

        
        .chart-container {
            height: 240px;
            padding: 1rem;
            margin: 1rem 0;
            display: flex;
            align-items: center;
            justify-content: center;
            position: relative;
        }
        
        #revenue-chart {
            max-width: 100%;
            max-height: 200px;
            cursor: crosshair;
        }
        
        .chart-tooltip {
            position: absolute;
            background: rgba(0, 0, 0, 0.9);
            color: white;
            padding: 8px 12px;
            border-radius: 6px;
            font-size: 12px;
            font-weight: 500;
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.2s ease;
            z-index: 1000;
            min-width: 120px;
            text-align: center;
        }
        
        .chart-tooltip.visible {
            opacity: 1;
        }
        
        .chart-tooltip .tooltip-label {
            font-weight: 600;
            margin-bottom: 2px;
        }
        
        .chart-tooltip .tooltip-value {
            font-size: 14px;
            color: #a78bfa;
        }
    </style>
</head>
<body>
    <header class="prototype-header">
        <div class="persona-selector-container">
            <div class="persona-selector-button" id="persona-selector-btn">
                <img class="persona-logo" id="current-persona-logo" alt="Modaic">
                <div class="persona-selector-text">
                    <div class="persona-name" id="current-persona-name">Modaic</div>
                </div>
                <svg class="dropdown-arrow" id="dropdown-arrow" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 9l-7 7-7-7"></path>
                </svg>
            </div>
            
            <!-- Popover -->
            <div class="persona-popover" id="persona-popover">
                <div class="popover-header">
                    <img class="popover-persona-logo" id="popover-persona-logo" alt="Modaic">
                    <div class="popover-persona-info">
                        <h3 id="popover-persona-name">Modaic</h3>
                        <p id="popover-persona-description">E-commerce fashion retailer with global payment processing.</p>
                    </div>
                </div>
                
                <button class="change-persona-btn" id="change-persona-btn">Change</button>
                
                <div class="stage-section">
                    <div class="stage-label">Stage</div>
                    <div class="stage-options">
                        <div class="stage-option" data-stage="early">Early</div>
                        <div class="stage-option selected" data-stage="growth">Growth</div>
                        <div class="stage-option" data-stage="mature">Enterprise</div>
                    </div>
                </div>
                
                <div class="stripe-products" id="current-stripe-products">
                    <span class="stripe-product-badge">Payments</span>
                    <span class="stripe-product-badge">Checkout</span>
                    <span class="stripe-product-badge">Subscriptions</span>
                    <span class="stripe-product-badge">Radar</span>
                </div>
            </div>
        </div>
    </header>
    
    <!-- Persona Selection Modal -->
    <div class="persona-modal" id="persona-modal">
        <div class="modal-content">
            <div class="modal-header">
                <h2 class="modal-title">Swap data scenarios</h2>
                <p class="modal-subtitle">Choose which business persona dataset to use in your prototype.</p>
            </div>
            
            <div class="personas-grid" id="personas-grid">
                <!-- Persona options will be populated here -->
            </div>
            
            <div class="modal-footer">
                <button class="btn btn-secondary" id="modal-cancel">Cancel</button>
                <button class="btn btn-primary" id="modal-done">Done</button>
            </div>
        </div>
    </div>

    <main class="prototype-main">
        <div class="loading-state active" id="loading-state">
            <h3>Loading dashboard data...</h3>
            <p>Initializing with default business scenario</p>
        </div>

        <div id="dashboard-content" style="display: none;">
            <!-- Metrics Cards -->
            <div class="metrics-grid" id="metrics-cards">
                <!-- Metrics will be populated here -->
            </div>

            <!-- Charts Section -->
            <div class="data-section">
                <div class="data-section-header">
                    <h3 class="data-section-title" id="chart-title">Revenue Trends</h3>
                </div>
                <div class="chart-container" id="chart-container">
                    <canvas id="revenue-chart" width="800" height="200"></canvas>
                    <div class="chart-tooltip" id="chart-tooltip">
                        <div class="tooltip-label"></div>
                        <div class="tooltip-value"></div>
                    </div>
                </div>
            </div>

            <!-- Data Tables -->
            <div class="data-section">
                <div class="data-section-header">
                    <h3 class="data-section-title" id="primary-table-title">Transactions</h3>
                </div>
                <table class="data-table">
                    <thead>
                        <tr id="table-headers">
                            <!-- Headers will be populated based on persona -->
                        </tr>
                    </thead>
                    <tbody id="table-body">
                        <!-- Data will be populated here -->
                    </tbody>
                </table>
            </div>

            <!-- Secondary Data Section -->
            <div class="data-section" id="secondary-section">
                <div class="data-section-header">
                    <h3 class="data-section-title" id="secondary-table-title">Customers</h3>
                </div>
                <table class="data-table">
                    <thead>
                        <tr id="secondary-headers">
                            <!-- Headers will be populated based on persona -->
                        </tr>
                    </thead>
                    <tbody id="secondary-body">
                        <!-- Data will be populated here -->
                    </tbody>
                </table>
            </div>
        </div>
    </main>

    <!-- Include the data client and persona switcher -->
    <script src="../stripe-data-client.js"></script>


    <script>
        // This is what the designer gets - a fully functional prototype
        class DashboardPrototype {
            constructor() {
                this.dataClient = null;
                this.personaSwitcher = null;
                this.currentData = null;
                this.currentPersona = null;
                
                this.init();
            }

            async init() {
                console.log('üéØ Initializing Dashboard Prototype...');
                
                try {
                    // Initialize data client with default persona
                    this.dataClient = new StripeDataClient({
                        defaultPersona: 'techstyle' // Can be changed to any persona
                    });

                    // Wait for initial load with timeout
                    await new Promise((resolve, reject) => {
                        let attempts = 0;
                        const maxAttempts = 50; // 5 seconds max
                        
                        const checkLoaded = () => {
                            attempts++;
                            console.log(`üìä Checking data load attempt ${attempts}, currentData:`, !!this.dataClient.currentData);
                            
                            if (this.dataClient.currentData) {
                                console.log('‚úÖ Data loaded successfully!');
                                resolve();
                            } else if (attempts >= maxAttempts) {
                                console.log('‚ö†Ô∏è Timeout waiting for data, proceeding anyway');
                                resolve(); // Don't reject, just proceed
                            } else {
                                setTimeout(checkLoaded, 100);
                            }
                        };
                        checkLoaded();
                    });

                                // Initialize navbar selectors
            this.initializeNavbarSelectors();

                    // Subscribe to data changes
                    this.dataClient.subscribe((data, personaId) => {
                        this.currentData = data;
                        this.currentPersona = personaId;
                        this.updatePersonaSelectorDisplay();
                        this.updateDashboard();
                    });

                    // Initial render
                    this.currentData = this.dataClient.currentData;
                    this.currentPersona = this.dataClient.currentPersona;
                    this.updatePersonaSelectorDisplay();
                    this.updateDashboard();

                } catch (error) {
                    console.error('Failed to initialize dashboard:', error);
                    this.showError('Failed to load dashboard data');
                }
            }

            updateDashboard() {
                console.log('üîÑ Updating dashboard with data:', {
                    persona: this.currentPersona,
                    dataKeys: Object.keys(this.currentData || {}),
                    hasMetrics: !!this.dataClient?.calculateMetrics
                });
                
                this.hideLoading();
                this.updatePersonaIndicator();
                this.updateMetrics();
                this.updateChart();
                this.updateTables();
            }

            hideLoading() {
                document.getElementById('loading-state').classList.remove('active');
                document.getElementById('dashboard-content').style.display = 'block';
            }

            updateChart() {
                try {
                    // Clean up previous chart if exists
                    if (this.currentChartData) {
                        this.destroyChart();
                    }
                    
                    const canvas = document.getElementById('revenue-chart');
                    if (!canvas) {
                        console.log('‚ùå Chart canvas not found');
                        return;
                    }
                    
                    const ctx = canvas.getContext('2d');
                    const metrics = this.dataClient?.calculateMetrics() || [];
                    
                    if (metrics.length === 0) {
                        console.log('‚ùå No metrics available for chart');
                        this.drawEmptyChart(ctx, canvas);
                        return;
                    }
                    
                    // Use the first metric for the time series
                    const primaryMetric = metrics[0];
                    console.log('üìà Drawing chart for metric:', primaryMetric.label);
                    
                    // Update chart title
                    const chartTitle = document.getElementById('chart-title');
                    if (chartTitle) {
                        chartTitle.textContent = `${primaryMetric.label} Trends`;
                    }
                    
                    // Generate time series data for the past 12 months
                    const timeSeriesData = this.generateTimeSeriesData(primaryMetric, this.currentPersona);
                    
                    // Initialize interactive chart
                    this.initializeInteractiveChart(canvas, ctx, timeSeriesData, primaryMetric);
                    
                } catch (error) {
                    console.error('Error updating chart:', error);
                }
            }
            
            initializeInteractiveChart(canvas, ctx, data, metric) {
                // Store chart data for interaction
                this.currentChartData = {
                    canvas,
                    ctx,
                    data,
                    metric,
                    padding: 40,
                    chartWidth: canvas.width - 80,
                    chartHeight: canvas.height - 80,
                    dataPoints: []
                };
                
                // Draw the initial chart
                this.drawInteractiveChart();
                
                // Remove existing event listeners
                this.removeChartEventListeners();
                
                // Add mouse event listeners for interactivity
                this.addChartEventListeners();
            }
            
            drawInteractiveChart() {
                const { canvas, ctx, data, padding, chartWidth, chartHeight } = this.currentChartData;
                const { months, values } = data;
                
                // Clear canvas
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                
                // Calculate scales
                const maxValue = Math.max(...values);
                const minValue = Math.min(...values);
                const valueRange = maxValue - minValue || 1;
                
                // Store data points for hover detection
                this.currentChartData.dataPoints = [];
                
                // Set up styling
                ctx.font = '12px -apple-system, BlinkMacSystemFont, sans-serif';
                ctx.fillStyle = '#64748b';
                
                // Draw grid and axes
                this.drawGrid(ctx, canvas, padding, chartWidth, chartHeight, minValue, maxValue, months);
                
                // Draw the line
                ctx.beginPath();
                ctx.strokeStyle = '#635bff';
                ctx.lineWidth = 3;
                
                for (let i = 0; i < values.length; i++) {
                    const x = padding + (i / (values.length - 1)) * chartWidth;
                    const y = padding + chartHeight - ((values[i] - minValue) / valueRange) * chartHeight;
                    
                    // Store point data for interaction
                    this.currentChartData.dataPoints.push({
                        x, y, 
                        value: values[i],
                        label: months[i],
                        index: i
                    });
                    
                    if (i === 0) {
                        ctx.moveTo(x, y);
                    } else {
                        ctx.lineTo(x, y);
                    }
                }
                ctx.stroke();
                
                // Draw data points
                ctx.fillStyle = '#635bff';
                this.currentChartData.dataPoints.forEach(point => {
                    ctx.beginPath();
                    ctx.arc(point.x, point.y, 4, 0, 2 * Math.PI);
                    ctx.fill();
                });
                
                // Draw hover point if any
                if (this.currentChartData.hoverPoint) {
                    this.drawHoverPoint(this.currentChartData.hoverPoint);
                }
            }
            
            addChartEventListeners() {
                const canvas = this.currentChartData.canvas;
                
                this.chartMouseMoveHandler = (e) => this.handleChartMouseMove(e);
                this.chartMouseLeaveHandler = (e) => this.handleChartMouseLeave(e);
                
                canvas.addEventListener('mousemove', this.chartMouseMoveHandler);
                canvas.addEventListener('mouseleave', this.chartMouseLeaveHandler);
            }
            
            removeChartEventListeners() {
                const canvas = this.currentChartData?.canvas;
                if (!canvas) return;
                
                if (this.chartMouseMoveHandler) {
                    canvas.removeEventListener('mousemove', this.chartMouseMoveHandler);
                }
                if (this.chartMouseLeaveHandler) {
                    canvas.removeEventListener('mouseleave', this.chartMouseLeaveHandler);
                }
            }
            
            handleChartMouseMove(e) {
                const canvas = this.currentChartData.canvas;
                const rect = canvas.getBoundingClientRect();
                const mouseX = e.clientX - rect.left;
                const mouseY = e.clientY - rect.top;
                
                // Find the closest data point
                let closestPoint = null;
                let minDistance = Infinity;
                
                this.currentChartData.dataPoints.forEach(point => {
                    const distance = Math.sqrt(Math.pow(mouseX - point.x, 2) + Math.pow(mouseY - point.y, 2));
                    if (distance < minDistance && distance < 20) { // 20px hover radius
                        minDistance = distance;
                        closestPoint = point;
                    }
                });
                
                if (closestPoint) {
                    this.showTooltip(closestPoint, e.clientX, e.clientY);
                    this.currentChartData.hoverPoint = closestPoint;
                    this.drawInteractiveChart(); // Redraw with hover highlight
                } else {
                    this.hideTooltip();
                    this.currentChartData.hoverPoint = null;
                    this.drawInteractiveChart(); // Redraw without hover
                }
            }
            
            handleChartMouseLeave(e) {
                this.hideTooltip();
                this.currentChartData.hoverPoint = null;
                this.drawInteractiveChart();
            }
            
            drawHoverPoint(point) {
                const { ctx } = this.currentChartData;
                
                // Draw larger highlighted point
                ctx.fillStyle = '#4f46e5';
                ctx.beginPath();
                ctx.arc(point.x, point.y, 6, 0, 2 * Math.PI);
                ctx.fill();
                
                // Draw white center
                ctx.fillStyle = 'white';
                ctx.beginPath();
                ctx.arc(point.x, point.y, 3, 0, 2 * Math.PI);
                ctx.fill();
                
                // Draw vertical line to x-axis
                ctx.strokeStyle = '#e2e8f0';
                ctx.lineWidth = 1;
                ctx.setLineDash([3, 3]);
                ctx.beginPath();
                ctx.moveTo(point.x, point.y);
                ctx.lineTo(point.x, this.currentChartData.padding + this.currentChartData.chartHeight);
                ctx.stroke();
                ctx.setLineDash([]);
            }
            
            showTooltip(point, clientX, clientY) {
                const tooltip = document.getElementById('chart-tooltip');
                const container = document.getElementById('chart-container');
                
                if (!tooltip || !container) return;
                
                const containerRect = container.getBoundingClientRect();
                const tooltipX = clientX - containerRect.left;
                const tooltipY = clientY - containerRect.top - 60;
                
                // Format the value based on metric type
                const formattedValue = this.formatTooltipValue(point.value, this.currentChartData.metric);
                
                tooltip.querySelector('.tooltip-label').textContent = point.label;
                tooltip.querySelector('.tooltip-value').textContent = formattedValue;
                
                tooltip.style.left = `${Math.max(10, Math.min(tooltipX - 60, container.clientWidth - 130))}px`;
                tooltip.style.top = `${Math.max(10, tooltipY)}px`;
                tooltip.classList.add('visible');
            }
            
            hideTooltip() {
                const tooltip = document.getElementById('chart-tooltip');
                if (tooltip) {
                    tooltip.classList.remove('visible');
                }
            }
            
            formatTooltipValue(value, metric) {
                // Determine format based on metric label
                const label = metric.label.toLowerCase();
                
                if (label.includes('revenue') || label.includes('mrr') || label.includes('arr') || 
                    label.includes('volume') || label.includes('raised') || label.includes('collected')) {
                    // Currency formatting
                    return new Intl.NumberFormat('en-US', {
                        style: 'currency',
                        currency: 'USD',
                        minimumFractionDigits: 0,
                        maximumFractionDigits: 0
                    }).format(value / 100);
                } else if (label.includes('rate') || label.includes('percent')) {
                    // Percentage formatting
                    return new Intl.NumberFormat('en-US', {
                        style: 'percent',
                        minimumFractionDigits: 1,
                        maximumFractionDigits: 1
                    }).format(value);
                } else {
                    // Number formatting
                    return new Intl.NumberFormat('en-US').format(value);
                }
            }
            
            generateTimeSeriesData(metric, personaId) {
                // Generate 12 months of realistic time series data
                const months = [];
                const values = [];
                const now = new Date();
                
                // Start 11 months ago
                for (let i = 11; i >= 0; i--) {
                    const date = new Date(now.getFullYear(), now.getMonth() - i, 1);
                    months.push(date.toLocaleDateString('en-US', { month: 'short', year: '2-digit' }));
                    
                    // Generate realistic progression based on current stage and business model
                    const baseValue = metric.rawValue || 0;
                    const stageMultiplier = this.getStageGrowthPattern(i, this.currentStage);
                    const businessGrowth = this.getBusinessGrowthPattern(i, personaId);
                    const randomVariation = 0.85 + Math.random() * 0.3; // ¬±15% variation
                    
                    const value = Math.floor(baseValue * stageMultiplier * businessGrowth * randomVariation);
                    values.push(Math.max(0, value));
                }
                
                return { months, values, label: metric.label };
            }
            
            getStageGrowthPattern(monthsAgo, stage) {
                // Different growth patterns based on business stage
                switch (stage) {
                    case 'early':
                        // Exponential growth from very small
                        return Math.pow(1.25, 11 - monthsAgo) * 0.1;
                    case 'growth':
                        // Steady growth
                        return 0.3 + (11 - monthsAgo) * 0.08;
                    case 'mature':
                        // Slower, steady growth
                        return 0.7 + (11 - monthsAgo) * 0.04;
                    default:
                        return 0.5 + (11 - monthsAgo) * 0.05;
                }
            }
            
            getBusinessGrowthPattern(monthsAgo, personaId) {
                // Seasonal patterns based on business type
                const seasonalMultipliers = {
                    'techstyle': [0.8, 0.9, 1.1, 1.2, 1.1, 0.9, 0.8, 0.9, 1.0, 1.1, 1.3, 1.4], // Fashion peaks in Q4
                    'edutech': [1.2, 1.0, 0.9, 0.8, 0.7, 0.6, 0.7, 1.3, 1.4, 1.2, 1.0, 0.9], // Education peaks in fall
                    'givehope': [0.9, 0.8, 0.9, 1.0, 1.0, 0.9, 0.8, 0.9, 1.0, 1.1, 1.2, 1.5], // Charity peaks in December
                    'fitstream': [1.4, 1.3, 1.1, 1.0, 1.1, 1.0, 0.9, 0.9, 1.0, 1.1, 1.2, 1.1], // Fitness peaks in January
                    'localbites': [0.9, 0.9, 1.0, 1.1, 1.2, 1.3, 1.2, 1.1, 1.0, 1.0, 1.1, 1.0] // Food delivery peaks in summer
                };
                
                const pattern = seasonalMultipliers[personaId] || [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1];
                const monthIndex = (11 - monthsAgo) % 12;
                return pattern[monthIndex];
            }
            
            // Cleanup method to remove event listeners
            destroyChart() {
                this.removeChartEventListeners();
                this.hideTooltip();
                this.currentChartData = null;
            }
            
            drawGrid(ctx, canvas, padding, chartWidth, chartHeight, minValue, maxValue, months) {
                ctx.strokeStyle = '#e2e8f0';
                ctx.lineWidth = 1;
                ctx.fillStyle = '#64748b';
                ctx.font = '11px -apple-system, BlinkMacSystemFont, sans-serif';
                
                // Draw horizontal grid lines and Y-axis labels
                const ySteps = 4;
                for (let i = 0; i <= ySteps; i++) {
                    const y = padding + (i / ySteps) * chartHeight;
                    const value = maxValue - (i / ySteps) * (maxValue - minValue);
                    
                    // Grid line
                    ctx.beginPath();
                    ctx.moveTo(padding, y);
                    ctx.lineTo(padding + chartWidth, y);
                    ctx.stroke();
                    
                    // Y-axis label
                    const labelText = this.formatChartValue(value);
                    ctx.fillText(labelText, 5, y + 4);
                }
                
                // Draw X-axis labels (months)
                for (let i = 0; i < months.length; i += 2) { // Show every other month
                    const x = padding + (i / (months.length - 1)) * chartWidth;
                    const y = padding + chartHeight + 15;
                    
                    ctx.save();
                    ctx.textAlign = 'center';
                    ctx.fillText(months[i], x, y);
                    ctx.restore();
                }
            }
            
            formatChartValue(value) {
                if (value >= 1000000) {
                    return (value / 1000000).toFixed(1) + 'M';
                } else if (value >= 1000) {
                    return (value / 1000).toFixed(0) + 'K';
                } else {
                    return value.toFixed(0);
                }
            }
            
            drawEmptyChart(ctx, canvas) {
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                ctx.fillStyle = '#64748b';
                ctx.font = '14px -apple-system, BlinkMacSystemFont, sans-serif';
                ctx.textAlign = 'center';
                ctx.fillText('No data available', canvas.width / 2, canvas.height / 2);
            }

            updatePersonaIndicator() {
                const personas = this.dataClient.getAvailablePersonas();
                const current = personas[this.currentPersona];
                
                // Legacy code removed - persona info now handled by updatePersonaMetadata()
            }



            updateMetrics() {
                try {
                    const metrics = this.dataClient?.calculateMetrics() || [];
                    console.log('üìà Calculated metrics:', metrics);
                    
                    const container = document.getElementById('metrics-cards');
                    if (!container) {
                        console.error('‚ùå Metrics container not found');
                        return;
                    }
                    
                    if (metrics.length === 0) {
                        console.warn('‚ö†Ô∏è No metrics calculated, using fallback');
                        container.innerHTML = `
                            <div class="metric-card">
                                <div class="metric-label">Total Revenue</div>
                                <div class="metric-value">$185,000,000</div>
                            </div>
                            <div class="metric-card">
                                <div class="metric-label">Success Rate</div>
                                <div class="metric-value">98.1%</div>
                            </div>
                            <div class="metric-card">
                                <div class="metric-label">Customers</div>
                                <div class="metric-value">75,000</div>
                            </div>
                            <div class="metric-card">
                                <div class="metric-label">Avg Order</div>
                                <div class="metric-value">$123</div>
                            </div>
                        `;
                        return;
                    }
                    
                    // Debug: Log each metric before rendering
                    metrics.forEach((metric, i) => {
                        console.log(`üìä Metric ${i}:`, metric);
                    });
                    
                    const html = metrics.map(metric => `
                        <div class="metric-card">
                            <div class="metric-label">${metric.label || 'Unknown'}</div>
                            <div class="metric-value">${metric.value || 'No Value'}</div>
                        </div>
                    `).join('');
                    
                    console.log('üñºÔ∏è Generated HTML:', html);
                    container.innerHTML = html;
                } catch (error) {
                    console.error('‚ùå Error updating metrics:', error);
                }
            }

            updateTables() {
                console.log('üìã Updating tables for persona:', this.currentPersona);
                console.log('üìã Current data for tables:', this.currentData);
                try {
                    // Update primary table based on persona
                    this.updatePrimaryTable();
                    this.updateSecondaryTable();
                } catch (error) {
                    console.error('‚ùå Error updating tables:', error);
                }
            }

            updatePrimaryTable() {
                const persona = this.currentPersona;
                let data, headers, title;

                console.log(`üîß updatePrimaryTable for ${persona}:`, {
                    currentData: this.currentData,
                    dataKeys: Object.keys(this.currentData || {}),
                    payments: this.currentData?.payments?.length,
                    customers: this.currentData?.customers?.length,
                    connected_accounts: this.currentData?.connected_accounts?.length,
                    paymentsExists: !!this.currentData?.payments,
                    firstPayment: this.currentData?.payments?.[0]
                });

                // All personas now use standardized Stripe objects - primarily payments
                switch (persona) {
                    case 'techstyle':
                        data = this.currentData.payments?.slice(0, 10) || [];
                        headers = ['Payment ID', 'Amount', 'Status', 'Currency', 'Customer'];
                        title = 'Recent Payments';
                        break;
                    case 'edutech':
                        data = this.currentData.payments?.slice(0, 10) || [];
                        headers = ['Payment ID', 'Amount', 'Status', 'Course', 'Customer'];
                        title = 'Course Payments';
                        break;
                    case 'propertyflow':
                        data = this.currentData.payments?.slice(0, 10) || [];
                        headers = ['Payment ID', 'Amount', 'Status', 'Property', 'Customer'];
                        title = 'Rent Payments';
                        break;
                    case 'fitstream':
                        data = this.currentData.payments?.slice(0, 10) || [];
                        headers = ['Payment ID', 'Amount', 'Status', 'Plan', 'Customer'];
                        title = 'Membership Payments';
                        break;
                    case 'creatorhub':
                        data = this.currentData.payments?.slice(0, 10) || [];
                        headers = ['Payment ID', 'Amount', 'Status', 'Content', 'Customer'];
                        title = 'Content Purchases';
                        break;
                    case 'givehope':
                        data = this.currentData.payments?.slice(0, 10) || [];
                        headers = ['Payment ID', 'Amount', 'Status', 'Campaign', 'Customer'];
                        title = 'Donations';
                        break;
                    case 'medsupply':
                        data = this.currentData.payments?.slice(0, 10) || [];
                        headers = ['Payment ID', 'Amount', 'Status', 'PO Number', 'Customer'];
                        title = 'Medical Supply Payments';
                        break;
                    case 'cloudflow':
                        data = this.currentData.payments?.slice(0, 10) || [];
                        headers = ['Payment ID', 'Amount', 'Status', 'Plan', 'Customer'];
                        title = 'SaaS Payments';
                        break;
                    case 'localbites':
                        data = this.currentData.payments?.slice(0, 10) || [];
                        headers = ['Payment ID', 'Amount', 'Status', 'Restaurant', 'Customer'];
                        title = 'Food Orders';
                        break;
                    default:
                        data = [];
                        headers = ['ID', 'Data', 'Status'];
                        title = 'Data Table';
                }

                document.getElementById('primary-table-title').textContent = title;
                this.populateTable('table-headers', 'table-body', headers, data, persona, 'primary');
            }

            updateSecondaryTable() {
                const persona = this.currentPersona;
                let data, headers, title;

                console.log(`üîß updateSecondaryTable for ${persona}:`, {
                    currentData: this.currentData,
                    dataKeys: Object.keys(this.currentData || {}),
                    payments: this.currentData?.payments?.length,
                    customers: this.currentData?.customers?.length,
                    connected_accounts: this.currentData?.connected_accounts?.length,
                    customersExists: !!this.currentData?.customers,
                    connectedAccountsExists: !!this.currentData?.connected_accounts,
                    firstCustomer: this.currentData?.customers?.[0],
                    firstConnectedAccount: this.currentData?.connected_accounts?.[0]
                });

                // Show customers for most personas, connected_accounts for marketplace personas
                switch (persona) {
                    case 'techstyle':
                        data = this.currentData.customers?.slice(0, 10) || [];
                        headers = ['Customer ID', 'Email', 'Name', 'Total Spend', 'Country'];
                        title = 'Top Customers';
                        break;
                    case 'edutech':
                        data = this.currentData.connected_accounts?.slice(0, 10) || [];
                        headers = ['Account ID', 'Instructor Name', 'Expertise', 'Rating', 'Students'];
                        title = 'Top Instructors';
                        break;
                    case 'propertyflow':
                        data = this.currentData.connected_accounts?.slice(0, 10) || [];
                        headers = ['Account ID', 'Landlord Name', 'Properties', 'Experience', 'Portfolio Value'];
                        title = 'Landlords';
                        break;
                    case 'fitstream':
                        data = this.currentData.customers?.slice(0, 10) || [];
                        headers = ['Customer ID', 'Email', 'Fitness Level', 'Goals', 'Check-ins'];
                        title = 'Members';
                        break;
                    case 'creatorhub':
                        data = this.currentData.connected_accounts?.slice(0, 10) || [];
                        headers = ['Account ID', 'Creator Name', 'Category', 'Followers', 'Content Count'];
                        title = 'Top Creators';
                        break;
                    case 'givehope':
                        data = this.currentData.customers?.slice(0, 10) || [];
                        headers = ['Customer ID', 'Email', 'Donor Type', 'Total Donated', 'Frequency'];
                        title = 'Top Donors';
                        break;
                    case 'medsupply':
                        data = this.currentData.customers?.slice(0, 10) || [];
                        headers = ['Customer ID', 'Hospital Name', 'Facility Type', 'Credit Limit', 'Total Spend'];
                        title = 'Healthcare Clients';
                        break;
                    case 'cloudflow':
                        data = this.currentData.customers?.slice(0, 10) || [];
                        headers = ['Customer ID', 'Company Name', 'Industry', 'Employee Count', 'Total Spend'];
                        title = 'Enterprise Customers';
                        break;
                    case 'localbites':
                        data = this.currentData.connected_accounts?.slice(0, 10) || [];
                        headers = ['Account ID', 'Business Name', 'Type', 'Rating', 'Total Orders'];
                        title = 'Restaurant Partners';
                        break;

                    default:
                        data = [];
                        headers = ['ID', 'Data'];
                        title = 'Secondary Data';
                }

                document.getElementById('secondary-table-title').textContent = title;
                this.populateTable('secondary-headers', 'secondary-body', headers, data, persona, 'secondary');
            }

            populateTable(headersId, bodyId, headers, data, persona, tableType) {
                console.log(`üîß populateTable called for ${persona} ${tableType}:`, {
                    headersId, bodyId, headers, 
                    dataLength: data?.length, 
                    data: data?.slice(0, 2) // Show first 2 items for debugging
                });
                
                // Populate headers
                document.getElementById(headersId).innerHTML = headers.map(h => `<th>${h}</th>`).join('');
                
                // Populate body
                const tbody = document.getElementById(bodyId);
                if (!data || data.length === 0) {
                    tbody.innerHTML = '<tr><td colspan="5">No data available</td></tr>';
                    console.warn(`‚ö†Ô∏è No data for ${persona} ${tableType} table`);
                    return;
                }
                
                try {
                    tbody.innerHTML = data.map((item, index) => {
                        try {
                            const row = this.formatTableRow(item, persona, tableType);
                            if (!row) {
                                console.error(`‚ùå formatTableRow returned empty for ${persona} ${tableType} item ${index}:`, item);
                                return '<tr><td colspan="5">Row formatting error</td></tr>';
                            }
                            return `<tr>${row}</tr>`;
                        } catch (error) {
                            console.error(`‚ùå Error formatting ${persona} ${tableType} row ${index}:`, error, item);
                            return '<tr><td colspan="5">Row error</td></tr>';
                        }
                    }).join('');
                } catch (error) {
                    console.error(`‚ùå Error populating ${persona} ${tableType} table:`, error);
                    tbody.innerHTML = '<tr><td colspan="5">Table error</td></tr>';
                }
            }

            formatTableRow(item, persona, tableType) {
                console.log(`üîß formatTableRow: ${persona} ${tableType}`, { item, keys: Object.keys(item || {}) });
                
                if (tableType === 'primary') {
                    // All primary tables show payments with persona-specific metadata
                    const result = this.formatPaymentRow(item, persona);
                    console.log(`üîß formatPaymentRow result for ${persona}:`, result);
                    return result;
                } else {
                    // Secondary tables show customers or connected_accounts
                    const result = this.formatSecondaryRow(item, persona);
                    console.log(`üîß formatSecondaryRow result for ${persona}:`, result);
                    return result;
                }
            }

            formatPaymentRow(item, persona) {
                // All personas use payments, but show different metadata in columns 4-5
                const baseColumns = `
                    <td>${item.id}</td>
                    <td>${this.formatCurrency(item.amount)}</td>
                    <td><span class="status-badge status-${item.status}">${item.status}</span></td>
                `;

                switch (persona) {
                    case 'techstyle':
                        return baseColumns + `
                            <td>${item.currency?.toUpperCase()}</td>
                            <td>${item.customer}</td>
                        `;
                    case 'edutech':
                        return baseColumns + `
                            <td>${item.metadata?.course_id || 'Course'}</td>
                            <td>${item.customer}</td>
                        `;
                    case 'propertyflow':
                        return baseColumns + `
                            <td>${item.metadata?.property_id || 'Property'}</td>
                            <td>${item.customer}</td>
                        `;
                    case 'fitstream':
                        return baseColumns + `
                            <td>${item.metadata?.plan_type || 'Plan'}</td>
                            <td>${item.customer}</td>
                        `;
                    case 'creatorhub':
                        return baseColumns + `
                            <td>${item.metadata?.content_type || 'Content'}</td>
                            <td>${item.customer}</td>
                        `;
                    case 'givehope':
                        return baseColumns + `
                            <td>${item.metadata?.campaign_id || 'Campaign'}</td>
                            <td>${item.customer}</td>
                        `;
                    case 'medsupply':
                        return baseColumns + `
                            <td>${item.metadata?.purchase_order || 'PO'}</td>
                            <td>${item.customer}</td>
                        `;
                    case 'cloudflow':
                        return baseColumns + `
                            <td>${item.metadata?.plan_tier || 'Plan'}</td>
                            <td>${item.customer}</td>
                        `;
                    case 'localbites':
                        return baseColumns + `
                            <td>${item.metadata?.restaurant_id || 'Restaurant'}</td>
                            <td>${item.customer}</td>
                        `;
                    default:
                        return baseColumns + `
                            <td>-</td>
                            <td>${item.customer}</td>
                        `;
                }
            }

            formatSecondaryRow(item, persona) {
                switch (persona) {
                    case 'techstyle':
                        // Customers
                        return `
                            <td>${item.id}</td>
                            <td>${item.email}</td>
                            <td>${item.name}</td>
                            <td>${this.formatCurrency(item.metadata?.total_spend || 0)}</td>
                            <td>${item.address?.country || 'US'}</td>
                        `;
                    case 'edutech':
                        // Connected accounts (instructors)
                        return `
                            <td>${item.id}</td>
                            <td>${item.business_profile?.name || 'Instructor'}</td>
                            <td>${item.metadata?.expertise || 'General'}</td>
                            <td>${item.metadata?.rating || '4.5'}‚≠ê</td>
                            <td>${item.metadata?.total_students || 0}</td>
                        `;
                    case 'propertyflow':
                        // Connected accounts (landlords)
                        return `
                            <td>${item.id}</td>
                            <td>${item.business_profile?.name || 'Landlord'}</td>
                            <td>${item.metadata?.properties_count || 0}</td>
                            <td>${item.metadata?.years_experience || 0} years</td>
                            <td>${this.formatCurrency(item.metadata?.portfolio_value || 0)}</td>
                        `;
                    case 'fitstream':
                        // Customers (members)
                        return `
                            <td>${item.id}</td>
                            <td>${item.email}</td>
                            <td>${item.metadata?.fitness_level || 'Beginner'}</td>
                            <td>${item.metadata?.goals || 'General'}</td>
                            <td>${item.metadata?.check_ins_this_month || 0}</td>
                        `;
                    case 'creatorhub':
                        // Connected accounts (creators)
                        return `
                            <td>${item.id}</td>
                            <td>${item.business_profile?.name || 'Creator'}</td>
                            <td>${item.metadata?.creator_category || 'Art'}</td>
                            <td>${item.metadata?.followers_count || 0}</td>
                            <td>${item.metadata?.content_count || 0}</td>
                        `;
                    case 'givehope':
                        // Customers (donors)
                        return `
                            <td>${item.id}</td>
                            <td>${item.email}</td>
                            <td>${item.metadata?.donor_type || 'Individual'}</td>
                            <td>${this.formatCurrency(item.metadata?.total_donated || 0)}</td>
                            <td>${item.metadata?.donation_frequency || 'One-time'}</td>
                        `;
                    case 'medsupply':
                        // Customers (hospitals)
                        return `
                            <td>${item.id}</td>
                            <td>${item.name}</td>
                            <td>${item.metadata?.facility_type || 'Hospital'}</td>
                            <td>${this.formatCurrency(item.metadata?.credit_limit || 0)}</td>
                            <td>${this.formatCurrency(item.metadata?.total_spend || 0)}</td>
                        `;
                    case 'cloudflow':
                        // Customers (companies)
                        return `
                            <td>${item.id}</td>
                            <td>${item.name}</td>
                            <td>${item.metadata?.industry || 'Technology'}</td>
                            <td>${item.metadata?.employee_count || 0}</td>
                            <td>${this.formatCurrency(item.metadata?.total_spend || 0)}</td>
                        `;
                    case 'localbites':
                        // Connected accounts (restaurants)
                        return `
                            <td>${item.id}</td>
                            <td>${item.business_profile?.name || 'Restaurant'}</td>
                            <td>${item.metadata?.account_type || 'Restaurant'}</td>
                            <td>${item.metadata?.rating || '4.5'}‚≠ê</td>
                            <td>${item.metadata?.total_orders || 0}</td>
                        `;
                    default:
                        return `
                            <td>${item.id}</td>
                            <td>-</td>
                        `;
                }
            }

            formatCurrency(cents) {
                return new Intl.NumberFormat('en-US', {
                    style: 'currency',
                    currency: 'USD',
                    minimumFractionDigits: 0
                }).format(cents / 100);
            }

            initializeNavbarSelectors() {
                // Initialize new persona selector UI
                this.initializePersonaSelector();
                this.setupPersonaUIEvents();
                this.populatePersonaModal();
                
                // Set initial stage
                this.currentStage = 'growth';
                this.updateStageSelection();
            }
            
            initializePersonaSelector() {
                // Set up the new persona selector interface
                this.selectedPersonaForModal = this.currentPersona;
                this.updatePersonaSelectorDisplay();
            }
            
            setupPersonaUIEvents() {
                // Persona selector button click
                const selectorBtn = document.getElementById('persona-selector-btn');
                const popover = document.getElementById('persona-popover');
                const dropdownArrow = document.getElementById('dropdown-arrow');
                
                selectorBtn.addEventListener('click', (e) => {
                    e.stopPropagation();
                    const isOpen = popover.classList.contains('show');
                    if (isOpen) {
                        this.closePopover();
                    } else {
                        this.openPopover();
                    }
                });
                
                // Close popover when clicking outside
                document.addEventListener('click', (e) => {
                    if (!selectorBtn.contains(e.target) && !popover.contains(e.target)) {
                        this.closePopover();
                    }
                });
                
                // Change persona button
                const changeBtn = document.getElementById('change-persona-btn');
                changeBtn.addEventListener('click', (e) => {
                    e.stopPropagation();
                    this.closePopover();
                    this.openPersonaModal();
                });
                
                // Stage options
                const stageOptions = document.querySelectorAll('.stage-option');
                stageOptions.forEach(option => {
                    option.addEventListener('click', (e) => {
                        const newStage = e.target.dataset.stage;
                        this.currentStage = newStage;
                        this.updateStageData();
                        this.updateStageSelection();
                    });
                });
                
                // Modal events
                const modal = document.getElementById('persona-modal');
                const modalCancel = document.getElementById('modal-cancel');
                const modalDone = document.getElementById('modal-done');
                
                modalCancel.addEventListener('click', () => {
                    this.closePersonaModal();
                });
                
                modalDone.addEventListener('click', () => {
                    this.applyPersonaSelection();
                });
                
                // Close modal when clicking backdrop
                modal.addEventListener('click', (e) => {
                    if (e.target === modal) {
                        this.closePersonaModal();
                    }
                });
            }
            
            openPopover() {
                const popover = document.getElementById('persona-popover');
                const arrow = document.getElementById('dropdown-arrow');
                const button = document.getElementById('persona-selector-btn');
                
                popover.classList.add('show');
                arrow.classList.add('open');
                button.classList.add('open');
            }
            
            closePopover() {
                const popover = document.getElementById('persona-popover');
                const arrow = document.getElementById('dropdown-arrow');
                const button = document.getElementById('persona-selector-btn');
                
                popover.classList.remove('show');
                arrow.classList.remove('open');
                button.classList.remove('open');
            }
            
            openPersonaModal() {
                const modal = document.getElementById('persona-modal');
                modal.classList.add('show');
                document.body.style.overflow = 'hidden';
            }
            
            closePersonaModal() {
                const modal = document.getElementById('persona-modal');
                modal.classList.remove('show');
                document.body.style.overflow = 'auto';
                // Reset selection to current persona
                this.selectedPersonaForModal = this.currentPersona;
                this.updateModalSelection();
            }
            
            updateStageSelection() {
                const stageOptions = document.querySelectorAll('.stage-option');
                stageOptions.forEach(option => {
                    option.classList.remove('selected');
                    if (option.dataset.stage === this.currentStage) {
                        option.classList.add('selected');
                    }
                });
            }
            
            updatePersonaSelectorDisplay() {
                console.log('üîÑ updatePersonaSelectorDisplay called');
                const personas = this.dataClient.getAvailablePersonas();
                console.log('üìã Available personas:', Object.keys(personas));
                const currentPersona = personas[this.currentPersona];
                console.log('üë§ Current persona data:', currentPersona);
                
                if (!currentPersona) {
                    console.error('‚ùå No current persona found for:', this.currentPersona);
                    return;
                }
                
                // Map persona IDs to their image filenames (based on new brand names)
                const personaImageMap = {
                    'techstyle': 'modaic',
                    'edutech': 'mindora', 
                    'propertyflow': 'keynest',
                    'fitstream': 'pulseon',
                    'creatorhub': 'fluxly',
                    'givehope': 'brightfund',
                    'medsupply': 'procura',
                    'cloudflow': 'stratus',
                    'localbites': 'forksy'
                };
                
                const imageFilename = personaImageMap[this.currentPersona] || this.currentPersona;
                console.log(`üé≠ Persona ${this.currentPersona} maps to image: ${imageFilename}.png`);
                
                // Update main selector button
                const logo = document.getElementById('current-persona-logo');
                const name = document.getElementById('current-persona-name');
                
                // Try multiple path variations for local dev and GitHub Pages
                const possiblePaths = [
                    `/docs/assets/${imageFilename}.png`, // Local dev from project root (localhost:8080)
                    `../assets/${imageFilename}.png`,  // GitHub Pages / relative from examples/
                    `assets/${imageFilename}.png`,     // Local dev from docs root
                    `./assets/${imageFilename}.png`    // Alternative relative
                ];
                
                const logoPath = possiblePaths[0]; // Start with the first one
                console.log('üñºÔ∏è Setting logo path:', logoPath);
                console.log('üñºÔ∏è All possible paths:', possiblePaths);
                console.log('üîç FIRST PATH SHOULD BE /docs/assets/ - is it?', possiblePaths[0]);
                logo.src = logoPath;
                logo.alt = currentPersona.name;
                
                // Add error handling for image loading
                // Add automatic fallback for different paths
                let currentPathIndex = 0;
                const tryNextPath = () => {
                    currentPathIndex++;
                    if (currentPathIndex < possiblePaths.length) {
                        const nextPath = possiblePaths[currentPathIndex];
                        console.log(`üîÑ Trying fallback path ${currentPathIndex + 1}:`, nextPath);
                        logo.src = nextPath;
                    } else {
                        console.error('‚ùå All logo paths failed for:', this.currentPersona);
                        logo.style.display = 'none';
                    }
                };
                
                logo.onerror = () => {
                    console.error('‚ùå Failed to load logo:', logo.src);
                    tryNextPath();
                };
                logo.onload = () => {
                    console.log('‚úÖ Logo loaded successfully:', logo.src);
                    logo.style.display = 'block';
                };
                name.textContent = currentPersona.name;
                
                // Update popover
                const popoverLogo = document.getElementById('popover-persona-logo');
                const popoverName = document.getElementById('popover-persona-name');
                const popoverDescription = document.getElementById('popover-persona-description');
                
                // Use the same fallback logic for popover
                const setupPopoverImage = () => {
                    let popoverPathIndex = 0;
                    const tryNextPopoverPath = () => {
                        popoverPathIndex++;
                        if (popoverPathIndex < possiblePaths.length) {
                            const nextPath = possiblePaths[popoverPathIndex];
                            console.log(`üîÑ Trying popover fallback path ${popoverPathIndex + 1}:`, nextPath);
                            popoverLogo.src = nextPath;
                        } else {
                            console.error('‚ùå All popover logo paths failed for:', this.currentPersona);
                            popoverLogo.style.display = 'none';
                        }
                    };
                    
                    popoverLogo.onerror = () => {
                        console.error('‚ùå Failed to load popover logo:', popoverLogo.src);
                        tryNextPopoverPath();
                    };
                    popoverLogo.onload = () => {
                        console.log('‚úÖ Popover logo loaded successfully:', popoverLogo.src);
                        popoverLogo.style.display = 'block';
                    };
                    
                    popoverLogo.src = possiblePaths[0];
                };
                
                setupPopoverImage();
                popoverLogo.alt = currentPersona.name;
                popoverName.textContent = currentPersona.name;
                popoverDescription.textContent = currentPersona.description;
                
                // Update Stripe products
                this.updateStripeProducts(currentPersona.stripe_products || []);
            }
            
            updateStripeProducts(products) {
                const container = document.getElementById('current-stripe-products');
                container.innerHTML = '';
                
                products.forEach(product => {
                    const badge = document.createElement('span');
                    badge.className = 'stripe-product-badge';
                    badge.textContent = product;
                    container.appendChild(badge);
                });
            }
            
            populatePersonaModal() {
                console.log('üé≠ populatePersonaModal called');
                const personas = this.dataClient.getAvailablePersonas();
                const grid = document.getElementById('personas-grid');
                
                console.log('üé≠ Found personas for modal:', Object.keys(personas));
                grid.innerHTML = '';
                
                // Use the same persona image mapping
                const personaImageMap = {
                    'techstyle': 'modaic',
                    'edutech': 'mindora', 
                    'propertyflow': 'keynest',
                    'fitstream': 'pulseon',
                    'creatorhub': 'fluxly',
                    'givehope': 'brightfund',
                    'medsupply': 'procura',
                    'cloudflow': 'stratus',
                    'localbites': 'forksy'
                };
                
                Object.entries(personas).forEach(([id, persona]) => {
                    console.log(`üé≠ Processing persona ${id}:`, persona);
                    const option = document.createElement('div');
                    option.className = 'persona-option';
                    option.dataset.personaId = id;
                    
                    if (id === this.currentPersona) {
                        option.classList.add('selected');
                    }
                    
                    const modalImageFilename = personaImageMap[id] || id;
                    
                    // Create persona option with fallback image loading
                    option.innerHTML = `
                        <img class="persona-option-logo" alt="${persona.name}">
                        <div class="persona-option-info">
                            <div class="persona-option-name">${persona.name}</div>
                            <div class="persona-option-description">${persona.description}</div>
                            <div class="stripe-products">
                                ${(persona.stripe_products || []).map(product => 
                                    `<span class="stripe-product-badge">${product}</span>`
                                ).join('')}
                            </div>
                        </div>
                    `;
                    
                    // Setup image fallback for modal option
                    const modalImg = option.querySelector('.persona-option-logo');
                    const modalPossiblePaths = [
                        `/docs/assets/${modalImageFilename}.png`,     // Local dev from project root (localhost:8080)
                        `../assets/${modalImageFilename}.png`,        // GitHub Pages / relative from examples/
                        `assets/${modalImageFilename}.png`,           // Local dev from docs root
                        `./assets/${modalImageFilename}.png`          // Alternative relative
                    ];
                    
                    let modalPathIndex = 0;
                    const tryNextModalPath = () => {
                        modalPathIndex++;
                        if (modalPathIndex < modalPossiblePaths.length) {
                            const nextPath = modalPossiblePaths[modalPathIndex];
                            console.log(`üîÑ Trying modal fallback path ${modalPathIndex + 1} for ${id}:`, nextPath);
                            modalImg.src = nextPath;
                        } else {
                            console.error(`‚ùå All modal logo paths failed for ${id}`);
                            modalImg.style.display = 'none';
                        }
                    };
                    
                    modalImg.onerror = () => {
                        console.error('‚ùå Failed to load modal logo:', modalImg.src);
                        tryNextModalPath();
                    };
                    modalImg.onload = () => {
                        console.log('‚úÖ Modal logo loaded successfully:', modalImg.src);
                    };
                    
                    console.log(`üîç MODAL: First path for ${id} (${modalImageFilename}) should be /docs/assets/ - is it?`, modalPossiblePaths[0]);
                    modalImg.src = modalPossiblePaths[0];
                    
                    option.addEventListener('click', () => {
                        // Remove selected from all options
                        grid.querySelectorAll('.persona-option').forEach(opt => {
                            opt.classList.remove('selected');
                        });
                        // Add selected to clicked option
                        option.classList.add('selected');
                        this.selectedPersonaForModal = id;
                    });
                    
                    grid.appendChild(option);
                });
            }
            
            updateModalSelection() {
                const grid = document.getElementById('personas-grid');
                grid.querySelectorAll('.persona-option').forEach(option => {
                    option.classList.remove('selected');
                    if (option.dataset.personaId === this.selectedPersonaForModal) {
                        option.classList.add('selected');
                    }
                });
            }
            
            async applyPersonaSelection() {
                if (this.selectedPersonaForModal && this.selectedPersonaForModal !== this.currentPersona) {
                    await this.switchPersona(this.selectedPersonaForModal);
                }
                this.closePersonaModal();
            }
            
            async switchPersona(personaId) {
                if (personaId === this.currentPersona) return;
                
                try {
                    await this.dataClient.switchPersona(personaId);
                    this.currentPersona = personaId;
                    this.updatePersonaSelectorDisplay();
                    this.updateDashboard();
                    this.animateSwitch();
                } catch (error) {
                    console.error('Failed to switch persona:', error);
                }
            }
            

            
            updateStageData() {
                console.log(`Stage changed to: ${this.currentStage}`);
                
                // Update the data client with new stage
                this.currentData = this.dataClient.updateStage(this.currentStage);
                
                // Refresh the dashboard with stage-appropriate data
                this.updateDashboard();
            }

            onPersonaSwitch(personaId) {
                // This is where designers can add custom logic when personas change
                console.log(`Dashboard switched to ${personaId}`);
                
                // Example: You could trigger custom animations, update charts, etc.
                this.animateSwitch();
            }

            animateSwitch() {
                // Simple animation to show the switch happened
                const content = document.getElementById('dashboard-content');
                content.style.opacity = '0.5';
                setTimeout(() => {
                    content.style.opacity = '1';
                }, 200);
            }

            showError(message) {
                document.getElementById('loading-state').innerHTML = `
                    <h3>Error</h3>
                    <p>${message}</p>
                `;
            }
        }

        // Initialize the dashboard when page loads
        document.addEventListener('DOMContentLoaded', () => {
            new DashboardPrototype();
        });
    </script>
</body>
</html>
