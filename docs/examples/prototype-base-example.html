<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Stripe Dashboard Prototype - Multi-Persona</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: #f8fafc;
            color: #1e293b;
            line-height: 1.6;
        }
        
        .prototype-header {
            background: white;
            border-bottom: 1px solid #e2e8f0;
            padding: 1rem 2rem;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        
        .prototype-header h1 {
            font-size: 1.5rem;
            font-weight: 600;
            color: #0f172a;
        }
        
        .nav-controls {
            display: flex;
            align-items: center;
            gap: 2rem;
        }
        
        .nav-selector-group {
            display: flex;
            gap: 1rem;
        }
        
        .nav-selector {
            display: flex;
            flex-direction: column;
            gap: 0.25rem;
        }
        
        .nav-selector label {
            font-size: 0.75rem;
            font-weight: 500;
            color: #64748b;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }
        
        .nav-selector select {
            min-width: 200px;
            padding: 0.5rem 0.75rem;
            border: 1px solid #e2e8f0;
            border-radius: 6px;
            background: white;
            font-size: 0.875rem;
            color: #1e293b;
            cursor: pointer;
        }
        
        .nav-selector select:focus {
            outline: none;
            border-color: #635bff;
            box-shadow: 0 0 0 3px rgba(99, 91, 255, 0.1);
        }
        
        .persona-metadata {
            display: flex;
            flex-direction: column;
            align-items: flex-end;
            gap: 0.5rem;
        }
        
        .persona-info {
            display: flex;
            flex-direction: column;
            align-items: flex-end;
        }
        
        .persona-name {
            font-weight: 600;
            color: #0f172a;
            font-size: 0.875rem;
        }
        
        .persona-description {
            font-size: 0.75rem;
            color: #64748b;
            text-align: right;
        }
        
        .stripe-products {
            display: flex;
            gap: 0.25rem;
            flex-wrap: wrap;
            justify-content: flex-end;
        }
        
        .stripe-product-badge {
            padding: 0.125rem 0.375rem;
            background: #f1f5f9;
            color: #475569;
            font-size: 0.625rem;
            font-weight: 500;
            border-radius: 4px;
            border: 1px solid #e2e8f0;
        }
        
        .prototype-main {
            padding: 2rem;
            max-width: 1200px;
            margin: 0 auto;
        }
        
        .metrics-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 1.5rem;
            margin-bottom: 2rem;
        }
        
        .metric-card {
            background: white;
            border-radius: 8px;
            padding: 1.5rem;
            border: 1px solid #e2e8f0;
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
        }
        
        .metric-label {
            font-size: 0.875rem;
            color: #64748b;
            margin-bottom: 0.5rem;
        }
        
        .metric-value {
            font-size: 2rem;
            font-weight: 700;
            color: #0f172a;
        }
        
        .data-section {
            background: white;
            border-radius: 8px;
            border: 1px solid #e2e8f0;
            margin-bottom: 2rem;
            overflow: hidden;
        }
        
        .data-section-header {
            padding: 1rem 1.5rem;
            border-bottom: 1px solid #e2e8f0;
            background: #f8fafc;
        }
        
        .data-section-title {
            font-size: 1.125rem;
            font-weight: 600;
        }
        
        .data-table {
            width: 100%;
            border-collapse: collapse;
        }
        
        .data-table th {
            background: #f8fafc;
            padding: 0.75rem 1.5rem;
            text-align: left;
            font-weight: 500;
            color: #374151;
            border-bottom: 1px solid #e2e8f0;
        }
        
        .data-table td {
            padding: 0.75rem 1.5rem;
            border-bottom: 1px solid #f1f5f9;
        }
        
        .data-table tr:hover {
            background: #f8fafc;
        }
        
        .status-badge {
            display: inline-block;
            padding: 0.25rem 0.5rem;
            border-radius: 4px;
            font-size: 0.75rem;
            font-weight: 500;
        }
        
        .status-succeeded {
            background: #dcfce7;
            color: #166534;
        }
        
        .status-failed {
            background: #fecaca;
            color: #991b1b;
        }
        
        .loading-state {
            display: none;
            text-align: center;
            padding: 2rem;
            color: #64748b;
        }
        
        .loading-state.active {
            display: block;
        }
        

        
        .chart-container {
            height: 240px;
            background: white;
            border-radius: 8px;
            border: 1px solid #e2e8f0;
            padding: 1rem;
            margin: 1rem 0;
            display: flex;
            align-items: center;
            justify-content: center;
            position: relative;
        }
        
        #revenue-chart {
            max-width: 100%;
            max-height: 200px;
            cursor: crosshair;
        }
        
        .chart-tooltip {
            position: absolute;
            background: rgba(0, 0, 0, 0.9);
            color: white;
            padding: 8px 12px;
            border-radius: 6px;
            font-size: 12px;
            font-weight: 500;
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.2s ease;
            z-index: 1000;
            min-width: 120px;
            text-align: center;
        }
        
        .chart-tooltip.visible {
            opacity: 1;
        }
        
        .chart-tooltip .tooltip-label {
            font-weight: 600;
            margin-bottom: 2px;
        }
        
        .chart-tooltip .tooltip-value {
            font-size: 14px;
            color: #a78bfa;
        }
    </style>
</head>
<body>
    <header class="prototype-header">
        <h1>Payment Dashboard Prototype</h1>
        <div class="nav-controls">
            <div class="nav-selector-group">
                <div class="nav-selector persona-selector">
                    <label>Business Model</label>
                    <select id="persona-select">
                        <option value="">Loading...</option>
                    </select>
                </div>
                <div class="nav-selector stage-selector">
                    <label>Business Stage</label>
                    <select id="stage-select">
                        <option value="early">Early Stage</option>
                        <option value="growth">Growth Stage</option>
                        <option value="mature">Mature Stage</option>
                    </select>
                </div>
            </div>
            <div class="persona-metadata" id="persona-metadata">
                <div class="persona-info">
                    <span class="persona-name" id="current-persona-name">Loading...</span>
                    <span class="persona-description" id="current-persona-description"></span>
                </div>
                <div class="stripe-products" id="stripe-products"></div>
            </div>
        </div>
    </header>

    <main class="prototype-main">
        <div class="loading-state active" id="loading-state">
            <h3>Loading dashboard data...</h3>
            <p>Initializing with default business scenario</p>
        </div>

        <div id="dashboard-content" style="display: none;">
            <!-- Metrics Cards -->
            <div class="metrics-grid" id="metrics-cards">
                <!-- Metrics will be populated here -->
            </div>

            <!-- Charts Section -->
            <div class="data-section">
                <div class="data-section-header">
                    <h3 class="data-section-title" id="chart-title">Revenue Trends</h3>
                </div>
                <div class="chart-container" id="chart-container">
                    <canvas id="revenue-chart" width="800" height="200"></canvas>
                    <div class="chart-tooltip" id="chart-tooltip">
                        <div class="tooltip-label"></div>
                        <div class="tooltip-value"></div>
                    </div>
                </div>
            </div>

            <!-- Data Tables -->
            <div class="data-section">
                <div class="data-section-header">
                    <h3 class="data-section-title" id="primary-table-title">Transactions</h3>
                </div>
                <table class="data-table">
                    <thead>
                        <tr id="table-headers">
                            <!-- Headers will be populated based on persona -->
                        </tr>
                    </thead>
                    <tbody id="table-body">
                        <!-- Data will be populated here -->
                    </tbody>
                </table>
            </div>

            <!-- Secondary Data Section -->
            <div class="data-section" id="secondary-section">
                <div class="data-section-header">
                    <h3 class="data-section-title" id="secondary-table-title">Customers</h3>
                </div>
                <table class="data-table">
                    <thead>
                        <tr id="secondary-headers">
                            <!-- Headers will be populated based on persona -->
                        </tr>
                    </thead>
                    <tbody id="secondary-body">
                        <!-- Data will be populated here -->
                    </tbody>
                </table>
            </div>
        </div>
    </main>

    <!-- Include the data client and persona switcher -->
    <script src="../stripe-data-client.js"></script>


    <script>
        // This is what the designer gets - a fully functional prototype
        class DashboardPrototype {
            constructor() {
                this.dataClient = null;
                this.personaSwitcher = null;
                this.currentData = null;
                this.currentPersona = null;
                
                this.init();
            }

            async init() {
                console.log('üéØ Initializing Dashboard Prototype...');
                
                try {
                    // Initialize data client with default persona
                    this.dataClient = new StripeDataClient({
                        defaultPersona: 'techstyle' // Can be changed to any persona
                    });

                    // Wait for initial load with timeout
                    await new Promise((resolve, reject) => {
                        let attempts = 0;
                        const maxAttempts = 50; // 5 seconds max
                        
                        const checkLoaded = () => {
                            attempts++;
                            console.log(`üìä Checking data load attempt ${attempts}, currentData:`, !!this.dataClient.currentData);
                            
                            if (this.dataClient.currentData) {
                                console.log('‚úÖ Data loaded successfully!');
                                resolve();
                            } else if (attempts >= maxAttempts) {
                                console.log('‚ö†Ô∏è Timeout waiting for data, proceeding anyway');
                                resolve(); // Don't reject, just proceed
                            } else {
                                setTimeout(checkLoaded, 100);
                            }
                        };
                        checkLoaded();
                    });

                                // Initialize navbar selectors
            this.initializeNavbarSelectors();

                    // Subscribe to data changes
                    this.dataClient.subscribe((data, personaId) => {
                        this.currentData = data;
                        this.currentPersona = personaId;
                        this.updatePersonaMetadata();
                        this.updateDashboard();
                    });

                    // Initial render
                    this.currentData = this.dataClient.currentData;
                    this.currentPersona = this.dataClient.currentPersona;
                    this.updatePersonaMetadata();
                    this.updateDashboard();

                } catch (error) {
                    console.error('Failed to initialize dashboard:', error);
                    this.showError('Failed to load dashboard data');
                }
            }

            updateDashboard() {
                console.log('üîÑ Updating dashboard with data:', {
                    persona: this.currentPersona,
                    dataKeys: Object.keys(this.currentData || {}),
                    hasMetrics: !!this.dataClient?.calculateMetrics
                });
                
                this.hideLoading();
                this.updatePersonaIndicator();
                this.updateMetrics();
                this.updateChart();
                this.updateTables();
            }

            hideLoading() {
                document.getElementById('loading-state').classList.remove('active');
                document.getElementById('dashboard-content').style.display = 'block';
            }

            updateChart() {
                try {
                    // Clean up previous chart if exists
                    if (this.currentChartData) {
                        this.destroyChart();
                    }
                    
                    const canvas = document.getElementById('revenue-chart');
                    if (!canvas) {
                        console.log('‚ùå Chart canvas not found');
                        return;
                    }
                    
                    const ctx = canvas.getContext('2d');
                    const metrics = this.dataClient?.calculateMetrics() || [];
                    
                    if (metrics.length === 0) {
                        console.log('‚ùå No metrics available for chart');
                        this.drawEmptyChart(ctx, canvas);
                        return;
                    }
                    
                    // Use the first metric for the time series
                    const primaryMetric = metrics[0];
                    console.log('üìà Drawing chart for metric:', primaryMetric.label);
                    
                    // Update chart title
                    const chartTitle = document.getElementById('chart-title');
                    if (chartTitle) {
                        chartTitle.textContent = `${primaryMetric.label} Trends`;
                    }
                    
                    // Generate time series data for the past 12 months
                    const timeSeriesData = this.generateTimeSeriesData(primaryMetric, this.currentPersona);
                    
                    // Initialize interactive chart
                    this.initializeInteractiveChart(canvas, ctx, timeSeriesData, primaryMetric);
                    
                } catch (error) {
                    console.error('Error updating chart:', error);
                }
            }
            
            initializeInteractiveChart(canvas, ctx, data, metric) {
                // Store chart data for interaction
                this.currentChartData = {
                    canvas,
                    ctx,
                    data,
                    metric,
                    padding: 40,
                    chartWidth: canvas.width - 80,
                    chartHeight: canvas.height - 80,
                    dataPoints: []
                };
                
                // Draw the initial chart
                this.drawInteractiveChart();
                
                // Remove existing event listeners
                this.removeChartEventListeners();
                
                // Add mouse event listeners for interactivity
                this.addChartEventListeners();
            }
            
            drawInteractiveChart() {
                const { canvas, ctx, data, padding, chartWidth, chartHeight } = this.currentChartData;
                const { months, values } = data;
                
                // Clear canvas
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                
                // Calculate scales
                const maxValue = Math.max(...values);
                const minValue = Math.min(...values);
                const valueRange = maxValue - minValue || 1;
                
                // Store data points for hover detection
                this.currentChartData.dataPoints = [];
                
                // Set up styling
                ctx.font = '12px -apple-system, BlinkMacSystemFont, sans-serif';
                ctx.fillStyle = '#64748b';
                
                // Draw grid and axes
                this.drawGrid(ctx, canvas, padding, chartWidth, chartHeight, minValue, maxValue, months);
                
                // Draw the line
                ctx.beginPath();
                ctx.strokeStyle = '#635bff';
                ctx.lineWidth = 3;
                
                for (let i = 0; i < values.length; i++) {
                    const x = padding + (i / (values.length - 1)) * chartWidth;
                    const y = padding + chartHeight - ((values[i] - minValue) / valueRange) * chartHeight;
                    
                    // Store point data for interaction
                    this.currentChartData.dataPoints.push({
                        x, y, 
                        value: values[i],
                        label: months[i],
                        index: i
                    });
                    
                    if (i === 0) {
                        ctx.moveTo(x, y);
                    } else {
                        ctx.lineTo(x, y);
                    }
                }
                ctx.stroke();
                
                // Draw data points
                ctx.fillStyle = '#635bff';
                this.currentChartData.dataPoints.forEach(point => {
                    ctx.beginPath();
                    ctx.arc(point.x, point.y, 4, 0, 2 * Math.PI);
                    ctx.fill();
                });
                
                // Draw hover point if any
                if (this.currentChartData.hoverPoint) {
                    this.drawHoverPoint(this.currentChartData.hoverPoint);
                }
            }
            
            addChartEventListeners() {
                const canvas = this.currentChartData.canvas;
                
                this.chartMouseMoveHandler = (e) => this.handleChartMouseMove(e);
                this.chartMouseLeaveHandler = (e) => this.handleChartMouseLeave(e);
                
                canvas.addEventListener('mousemove', this.chartMouseMoveHandler);
                canvas.addEventListener('mouseleave', this.chartMouseLeaveHandler);
            }
            
            removeChartEventListeners() {
                const canvas = this.currentChartData?.canvas;
                if (!canvas) return;
                
                if (this.chartMouseMoveHandler) {
                    canvas.removeEventListener('mousemove', this.chartMouseMoveHandler);
                }
                if (this.chartMouseLeaveHandler) {
                    canvas.removeEventListener('mouseleave', this.chartMouseLeaveHandler);
                }
            }
            
            handleChartMouseMove(e) {
                const canvas = this.currentChartData.canvas;
                const rect = canvas.getBoundingClientRect();
                const mouseX = e.clientX - rect.left;
                const mouseY = e.clientY - rect.top;
                
                // Find the closest data point
                let closestPoint = null;
                let minDistance = Infinity;
                
                this.currentChartData.dataPoints.forEach(point => {
                    const distance = Math.sqrt(Math.pow(mouseX - point.x, 2) + Math.pow(mouseY - point.y, 2));
                    if (distance < minDistance && distance < 20) { // 20px hover radius
                        minDistance = distance;
                        closestPoint = point;
                    }
                });
                
                if (closestPoint) {
                    this.showTooltip(closestPoint, e.clientX, e.clientY);
                    this.currentChartData.hoverPoint = closestPoint;
                    this.drawInteractiveChart(); // Redraw with hover highlight
                } else {
                    this.hideTooltip();
                    this.currentChartData.hoverPoint = null;
                    this.drawInteractiveChart(); // Redraw without hover
                }
            }
            
            handleChartMouseLeave(e) {
                this.hideTooltip();
                this.currentChartData.hoverPoint = null;
                this.drawInteractiveChart();
            }
            
            drawHoverPoint(point) {
                const { ctx } = this.currentChartData;
                
                // Draw larger highlighted point
                ctx.fillStyle = '#4f46e5';
                ctx.beginPath();
                ctx.arc(point.x, point.y, 6, 0, 2 * Math.PI);
                ctx.fill();
                
                // Draw white center
                ctx.fillStyle = 'white';
                ctx.beginPath();
                ctx.arc(point.x, point.y, 3, 0, 2 * Math.PI);
                ctx.fill();
                
                // Draw vertical line to x-axis
                ctx.strokeStyle = '#e2e8f0';
                ctx.lineWidth = 1;
                ctx.setLineDash([3, 3]);
                ctx.beginPath();
                ctx.moveTo(point.x, point.y);
                ctx.lineTo(point.x, this.currentChartData.padding + this.currentChartData.chartHeight);
                ctx.stroke();
                ctx.setLineDash([]);
            }
            
            showTooltip(point, clientX, clientY) {
                const tooltip = document.getElementById('chart-tooltip');
                const container = document.getElementById('chart-container');
                
                if (!tooltip || !container) return;
                
                const containerRect = container.getBoundingClientRect();
                const tooltipX = clientX - containerRect.left;
                const tooltipY = clientY - containerRect.top - 60;
                
                // Format the value based on metric type
                const formattedValue = this.formatTooltipValue(point.value, this.currentChartData.metric);
                
                tooltip.querySelector('.tooltip-label').textContent = point.label;
                tooltip.querySelector('.tooltip-value').textContent = formattedValue;
                
                tooltip.style.left = `${Math.max(10, Math.min(tooltipX - 60, container.clientWidth - 130))}px`;
                tooltip.style.top = `${Math.max(10, tooltipY)}px`;
                tooltip.classList.add('visible');
            }
            
            hideTooltip() {
                const tooltip = document.getElementById('chart-tooltip');
                if (tooltip) {
                    tooltip.classList.remove('visible');
                }
            }
            
            formatTooltipValue(value, metric) {
                // Determine format based on metric label
                const label = metric.label.toLowerCase();
                
                if (label.includes('revenue') || label.includes('mrr') || label.includes('arr') || 
                    label.includes('volume') || label.includes('raised') || label.includes('collected')) {
                    // Currency formatting
                    return new Intl.NumberFormat('en-US', {
                        style: 'currency',
                        currency: 'USD',
                        minimumFractionDigits: 0,
                        maximumFractionDigits: 0
                    }).format(value / 100);
                } else if (label.includes('rate') || label.includes('percent')) {
                    // Percentage formatting
                    return new Intl.NumberFormat('en-US', {
                        style: 'percent',
                        minimumFractionDigits: 1,
                        maximumFractionDigits: 1
                    }).format(value);
                } else {
                    // Number formatting
                    return new Intl.NumberFormat('en-US').format(value);
                }
            }
            
            generateTimeSeriesData(metric, personaId) {
                // Generate 12 months of realistic time series data
                const months = [];
                const values = [];
                const now = new Date();
                
                // Start 11 months ago
                for (let i = 11; i >= 0; i--) {
                    const date = new Date(now.getFullYear(), now.getMonth() - i, 1);
                    months.push(date.toLocaleDateString('en-US', { month: 'short', year: '2-digit' }));
                    
                    // Generate realistic progression based on current stage and business model
                    const baseValue = metric.rawValue || 0;
                    const stageMultiplier = this.getStageGrowthPattern(i, this.currentStage);
                    const businessGrowth = this.getBusinessGrowthPattern(i, personaId);
                    const randomVariation = 0.85 + Math.random() * 0.3; // ¬±15% variation
                    
                    const value = Math.floor(baseValue * stageMultiplier * businessGrowth * randomVariation);
                    values.push(Math.max(0, value));
                }
                
                return { months, values, label: metric.label };
            }
            
            getStageGrowthPattern(monthsAgo, stage) {
                // Different growth patterns based on business stage
                switch (stage) {
                    case 'early':
                        // Exponential growth from very small
                        return Math.pow(1.25, 11 - monthsAgo) * 0.1;
                    case 'growth':
                        // Steady growth
                        return 0.3 + (11 - monthsAgo) * 0.08;
                    case 'mature':
                        // Slower, steady growth
                        return 0.7 + (11 - monthsAgo) * 0.04;
                    default:
                        return 0.5 + (11 - monthsAgo) * 0.05;
                }
            }
            
            getBusinessGrowthPattern(monthsAgo, personaId) {
                // Seasonal patterns based on business type
                const seasonalMultipliers = {
                    'techstyle': [0.8, 0.9, 1.1, 1.2, 1.1, 0.9, 0.8, 0.9, 1.0, 1.1, 1.3, 1.4], // Fashion peaks in Q4
                    'edutech': [1.2, 1.0, 0.9, 0.8, 0.7, 0.6, 0.7, 1.3, 1.4, 1.2, 1.0, 0.9], // Education peaks in fall
                    'givehope': [0.9, 0.8, 0.9, 1.0, 1.0, 0.9, 0.8, 0.9, 1.0, 1.1, 1.2, 1.5], // Charity peaks in December
                    'fitstream': [1.4, 1.3, 1.1, 1.0, 1.1, 1.0, 0.9, 0.9, 1.0, 1.1, 1.2, 1.1], // Fitness peaks in January
                    'localbites': [0.9, 0.9, 1.0, 1.1, 1.2, 1.3, 1.2, 1.1, 1.0, 1.0, 1.1, 1.0] // Food delivery peaks in summer
                };
                
                const pattern = seasonalMultipliers[personaId] || [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1];
                const monthIndex = (11 - monthsAgo) % 12;
                return pattern[monthIndex];
            }
            
            // Cleanup method to remove event listeners
            destroyChart() {
                this.removeChartEventListeners();
                this.hideTooltip();
                this.currentChartData = null;
            }
            
            drawGrid(ctx, canvas, padding, chartWidth, chartHeight, minValue, maxValue, months) {
                ctx.strokeStyle = '#e2e8f0';
                ctx.lineWidth = 1;
                ctx.fillStyle = '#64748b';
                ctx.font = '11px -apple-system, BlinkMacSystemFont, sans-serif';
                
                // Draw horizontal grid lines and Y-axis labels
                const ySteps = 4;
                for (let i = 0; i <= ySteps; i++) {
                    const y = padding + (i / ySteps) * chartHeight;
                    const value = maxValue - (i / ySteps) * (maxValue - minValue);
                    
                    // Grid line
                    ctx.beginPath();
                    ctx.moveTo(padding, y);
                    ctx.lineTo(padding + chartWidth, y);
                    ctx.stroke();
                    
                    // Y-axis label
                    const labelText = this.formatChartValue(value);
                    ctx.fillText(labelText, 5, y + 4);
                }
                
                // Draw X-axis labels (months)
                for (let i = 0; i < months.length; i += 2) { // Show every other month
                    const x = padding + (i / (months.length - 1)) * chartWidth;
                    const y = padding + chartHeight + 15;
                    
                    ctx.save();
                    ctx.textAlign = 'center';
                    ctx.fillText(months[i], x, y);
                    ctx.restore();
                }
            }
            
            formatChartValue(value) {
                if (value >= 1000000) {
                    return (value / 1000000).toFixed(1) + 'M';
                } else if (value >= 1000) {
                    return (value / 1000).toFixed(0) + 'K';
                } else {
                    return value.toFixed(0);
                }
            }
            
            drawEmptyChart(ctx, canvas) {
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                ctx.fillStyle = '#64748b';
                ctx.font = '14px -apple-system, BlinkMacSystemFont, sans-serif';
                ctx.textAlign = 'center';
                ctx.fillText('No data available', canvas.width / 2, canvas.height / 2);
            }

            updatePersonaIndicator() {
                const personas = this.dataClient.getAvailablePersonas();
                const current = personas[this.currentPersona];
                
                // Legacy code removed - persona info now handled by updatePersonaMetadata()
            }



            updateMetrics() {
                try {
                    const metrics = this.dataClient?.calculateMetrics() || [];
                    console.log('üìà Calculated metrics:', metrics);
                    
                    const container = document.getElementById('metrics-cards');
                    if (!container) {
                        console.error('‚ùå Metrics container not found');
                        return;
                    }
                    
                    if (metrics.length === 0) {
                        console.warn('‚ö†Ô∏è No metrics calculated, using fallback');
                        container.innerHTML = `
                            <div class="metric-card">
                                <div class="metric-label">Total Revenue</div>
                                <div class="metric-value">$185,000,000</div>
                            </div>
                            <div class="metric-card">
                                <div class="metric-label">Success Rate</div>
                                <div class="metric-value">98.1%</div>
                            </div>
                            <div class="metric-card">
                                <div class="metric-label">Customers</div>
                                <div class="metric-value">75,000</div>
                            </div>
                            <div class="metric-card">
                                <div class="metric-label">Avg Order</div>
                                <div class="metric-value">$123</div>
                            </div>
                        `;
                        return;
                    }
                    
                    // Debug: Log each metric before rendering
                    metrics.forEach((metric, i) => {
                        console.log(`üìä Metric ${i}:`, metric);
                    });
                    
                    const html = metrics.map(metric => `
                        <div class="metric-card">
                            <div class="metric-label">${metric.label || 'Unknown'}</div>
                            <div class="metric-value">${metric.value || 'No Value'}</div>
                        </div>
                    `).join('');
                    
                    console.log('üñºÔ∏è Generated HTML:', html);
                    container.innerHTML = html;
                } catch (error) {
                    console.error('‚ùå Error updating metrics:', error);
                }
            }

            updateTables() {
                console.log('üìã Updating tables for persona:', this.currentPersona);
                console.log('üìã Current data for tables:', this.currentData);
                try {
                    // Update primary table based on persona
                    this.updatePrimaryTable();
                    this.updateSecondaryTable();
                } catch (error) {
                    console.error('‚ùå Error updating tables:', error);
                }
            }

            updatePrimaryTable() {
                const persona = this.currentPersona;
                let data, headers, title;

                // All personas now use standardized Stripe objects - primarily payments
                switch (persona) {
                    case 'techstyle':
                        data = this.currentData.payments?.slice(0, 10) || [];
                        headers = ['Payment ID', 'Amount', 'Status', 'Currency', 'Customer'];
                        title = 'Recent Payments';
                        break;
                    case 'edutech':
                        data = this.currentData.payments?.slice(0, 10) || [];
                        headers = ['Payment ID', 'Amount', 'Status', 'Course', 'Customer'];
                        title = 'Course Payments';
                        break;
                    case 'propertyflow':
                        data = this.currentData.payments?.slice(0, 10) || [];
                        headers = ['Payment ID', 'Amount', 'Status', 'Property', 'Customer'];
                        title = 'Rent Payments';
                        break;
                    case 'fitstream':
                        data = this.currentData.payments?.slice(0, 10) || [];
                        headers = ['Payment ID', 'Amount', 'Status', 'Plan', 'Customer'];
                        title = 'Membership Payments';
                        break;
                    case 'creatorhub':
                        data = this.currentData.payments?.slice(0, 10) || [];
                        headers = ['Payment ID', 'Amount', 'Status', 'Content', 'Customer'];
                        title = 'Content Purchases';
                        break;
                    case 'givehope':
                        data = this.currentData.payments?.slice(0, 10) || [];
                        headers = ['Payment ID', 'Amount', 'Status', 'Campaign', 'Customer'];
                        title = 'Donations';
                        break;
                    case 'medsupply':
                        data = this.currentData.payments?.slice(0, 10) || [];
                        headers = ['Payment ID', 'Amount', 'Status', 'PO Number', 'Customer'];
                        title = 'Medical Supply Payments';
                        break;
                    case 'cloudflow':
                        data = this.currentData.payments?.slice(0, 10) || [];
                        headers = ['Payment ID', 'Amount', 'Status', 'Plan', 'Customer'];
                        title = 'SaaS Payments';
                        break;
                    case 'localbites':
                        data = this.currentData.payments?.slice(0, 10) || [];
                        headers = ['Payment ID', 'Amount', 'Status', 'Restaurant', 'Customer'];
                        title = 'Food Orders';
                        break;
                    default:
                        data = [];
                        headers = ['ID', 'Data', 'Status'];
                        title = 'Data Table';
                }

                document.getElementById('primary-table-title').textContent = title;
                this.populateTable('table-headers', 'table-body', headers, data, persona, 'primary');
            }

            updateSecondaryTable() {
                const persona = this.currentPersona;
                let data, headers, title;

                // Show customers for most personas, connected_accounts for marketplace personas
                switch (persona) {
                    case 'techstyle':
                        data = this.currentData.customers?.slice(0, 10) || [];
                        headers = ['Customer ID', 'Email', 'Name', 'Total Spend', 'Country'];
                        title = 'Top Customers';
                        break;
                    case 'edutech':
                        data = this.currentData.connected_accounts?.slice(0, 10) || [];
                        headers = ['Account ID', 'Instructor Name', 'Expertise', 'Rating', 'Students'];
                        title = 'Top Instructors';
                        break;
                    case 'propertyflow':
                        data = this.currentData.connected_accounts?.slice(0, 10) || [];
                        headers = ['Account ID', 'Landlord Name', 'Properties', 'Experience', 'Portfolio Value'];
                        title = 'Landlords';
                        break;
                    case 'fitstream':
                        data = this.currentData.customers?.slice(0, 10) || [];
                        headers = ['Customer ID', 'Email', 'Fitness Level', 'Goals', 'Check-ins'];
                        title = 'Members';
                        break;
                    case 'creatorhub':
                        data = this.currentData.connected_accounts?.slice(0, 10) || [];
                        headers = ['Account ID', 'Creator Name', 'Category', 'Followers', 'Content Count'];
                        title = 'Top Creators';
                        break;
                    case 'givehope':
                        data = this.currentData.customers?.slice(0, 10) || [];
                        headers = ['Customer ID', 'Email', 'Donor Type', 'Total Donated', 'Frequency'];
                        title = 'Top Donors';
                        break;
                    case 'medsupply':
                        data = this.currentData.customers?.slice(0, 10) || [];
                        headers = ['Customer ID', 'Hospital Name', 'Facility Type', 'Credit Limit', 'Total Spend'];
                        title = 'Healthcare Clients';
                        break;
                    case 'cloudflow':
                        data = this.currentData.customers?.slice(0, 10) || [];
                        headers = ['Customer ID', 'Company Name', 'Industry', 'Employee Count', 'Total Spend'];
                        title = 'Enterprise Customers';
                        break;
                    case 'localbites':
                        data = this.currentData.connected_accounts?.slice(0, 10) || [];
                        headers = ['Account ID', 'Business Name', 'Type', 'Rating', 'Total Orders'];
                        title = 'Restaurant Partners';
                        break;

                    default:
                        data = [];
                        headers = ['ID', 'Data'];
                        title = 'Secondary Data';
                }

                document.getElementById('secondary-table-title').textContent = title;
                this.populateTable('secondary-headers', 'secondary-body', headers, data, persona, 'secondary');
            }

            populateTable(headersId, bodyId, headers, data, persona, tableType) {
                // Populate headers
                document.getElementById(headersId).innerHTML = headers.map(h => `<th>${h}</th>`).join('');
                
                // Populate body
                const tbody = document.getElementById(bodyId);
                tbody.innerHTML = data.map(item => {
                    const row = this.formatTableRow(item, persona, tableType);
                    return `<tr>${row}</tr>`;
                }).join('');
            }

            formatTableRow(item, persona, tableType) {
                if (tableType === 'primary') {
                    // All primary tables show payments with persona-specific metadata
                    return this.formatPaymentRow(item, persona);
                } else {
                    // Secondary tables show customers or connected_accounts
                    return this.formatSecondaryRow(item, persona);
                }
            }

            formatPaymentRow(item, persona) {
                // All personas use payments, but show different metadata in columns 4-5
                const baseColumns = `
                    <td>${item.id}</td>
                    <td>${this.formatCurrency(item.amount)}</td>
                    <td><span class="status-badge status-${item.status}">${item.status}</span></td>
                `;

                switch (persona) {
                    case 'techstyle':
                        return baseColumns + `
                            <td>${item.currency?.toUpperCase()}</td>
                            <td>${item.customer}</td>
                        `;
                    case 'edutech':
                        return baseColumns + `
                            <td>${item.metadata?.course_id || 'Course'}</td>
                            <td>${item.customer}</td>
                        `;
                    case 'propertyflow':
                        return baseColumns + `
                            <td>${item.metadata?.property_id || 'Property'}</td>
                            <td>${item.customer}</td>
                        `;
                    case 'fitstream':
                        return baseColumns + `
                            <td>${item.metadata?.plan_type || 'Plan'}</td>
                            <td>${item.customer}</td>
                        `;
                    case 'creatorhub':
                        return baseColumns + `
                            <td>${item.metadata?.content_type || 'Content'}</td>
                            <td>${item.customer}</td>
                        `;
                    case 'givehope':
                        return baseColumns + `
                            <td>${item.metadata?.campaign_id || 'Campaign'}</td>
                            <td>${item.customer}</td>
                        `;
                    case 'medsupply':
                        return baseColumns + `
                            <td>${item.metadata?.purchase_order || 'PO'}</td>
                            <td>${item.customer}</td>
                        `;
                    case 'cloudflow':
                        return baseColumns + `
                            <td>${item.metadata?.plan_tier || 'Plan'}</td>
                            <td>${item.customer}</td>
                        `;
                    case 'localbites':
                        return baseColumns + `
                            <td>${item.metadata?.restaurant_id || 'Restaurant'}</td>
                            <td>${item.customer}</td>
                        `;
                    default:
                        return baseColumns + `
                            <td>-</td>
                            <td>${item.customer}</td>
                        `;
                }
            }

            formatSecondaryRow(item, persona) {
                switch (persona) {
                    case 'techstyle':
                        // Customers
                        return `
                            <td>${item.id}</td>
                            <td>${item.email}</td>
                            <td>${item.name}</td>
                            <td>${this.formatCurrency(item.metadata?.total_spend || 0)}</td>
                            <td>${item.address?.country || 'US'}</td>
                        `;
                    case 'edutech':
                        // Connected accounts (instructors)
                        return `
                            <td>${item.id}</td>
                            <td>${item.business_profile?.name || 'Instructor'}</td>
                            <td>${item.metadata?.expertise || 'General'}</td>
                            <td>${item.metadata?.rating || '4.5'}‚≠ê</td>
                            <td>${item.metadata?.total_students || 0}</td>
                        `;
                    case 'propertyflow':
                        // Connected accounts (landlords)
                        return `
                            <td>${item.id}</td>
                            <td>${item.business_profile?.name || 'Landlord'}</td>
                            <td>${item.metadata?.properties_count || 0}</td>
                            <td>${item.metadata?.years_experience || 0} years</td>
                            <td>${this.formatCurrency(item.metadata?.portfolio_value || 0)}</td>
                        `;
                    case 'fitstream':
                        // Customers (members)
                        return `
                            <td>${item.id}</td>
                            <td>${item.email}</td>
                            <td>${item.metadata?.fitness_level || 'Beginner'}</td>
                            <td>${item.metadata?.goals || 'General'}</td>
                            <td>${item.metadata?.check_ins_this_month || 0}</td>
                        `;
                    case 'creatorhub':
                        // Connected accounts (creators)
                        return `
                            <td>${item.id}</td>
                            <td>${item.business_profile?.name || 'Creator'}</td>
                            <td>${item.metadata?.creator_category || 'Art'}</td>
                            <td>${item.metadata?.followers_count || 0}</td>
                            <td>${item.metadata?.content_count || 0}</td>
                        `;
                    case 'givehope':
                        // Customers (donors)
                        return `
                            <td>${item.id}</td>
                            <td>${item.email}</td>
                            <td>${item.metadata?.donor_type || 'Individual'}</td>
                            <td>${this.formatCurrency(item.metadata?.total_donated || 0)}</td>
                            <td>${item.metadata?.donation_frequency || 'One-time'}</td>
                        `;
                    case 'medsupply':
                        // Customers (hospitals)
                        return `
                            <td>${item.id}</td>
                            <td>${item.name}</td>
                            <td>${item.metadata?.facility_type || 'Hospital'}</td>
                            <td>${this.formatCurrency(item.metadata?.credit_limit || 0)}</td>
                            <td>${this.formatCurrency(item.metadata?.total_spend || 0)}</td>
                        `;
                    case 'cloudflow':
                        // Customers (companies)
                        return `
                            <td>${item.id}</td>
                            <td>${item.name}</td>
                            <td>${item.metadata?.industry || 'Technology'}</td>
                            <td>${item.metadata?.employee_count || 0}</td>
                            <td>${this.formatCurrency(item.metadata?.total_spend || 0)}</td>
                        `;
                    case 'localbites':
                        // Connected accounts (restaurants)
                        return `
                            <td>${item.id}</td>
                            <td>${item.business_profile?.name || 'Restaurant'}</td>
                            <td>${item.metadata?.account_type || 'Restaurant'}</td>
                            <td>${item.metadata?.rating || '4.5'}‚≠ê</td>
                            <td>${item.metadata?.total_orders || 0}</td>
                        `;
                    default:
                        return `
                            <td>${item.id}</td>
                            <td>-</td>
                        `;
                }
            }

            formatCurrency(cents) {
                return new Intl.NumberFormat('en-US', {
                    style: 'currency',
                    currency: 'USD',
                    minimumFractionDigits: 0
                }).format(cents / 100);
            }

            initializeNavbarSelectors() {
                // Populate persona selector
                this.populatePersonaSelector();
                
                // Bind persona selector event
                const personaSelect = document.getElementById('persona-select');
                personaSelect.addEventListener('change', (e) => {
                    if (e.target.value) {
                        this.switchPersona(e.target.value);
                    }
                });
                
                // Bind stage selector event
                const stageSelect = document.getElementById('stage-select');
                stageSelect.addEventListener('change', (e) => {
                    this.currentStage = e.target.value;
                    this.updateStageData();
                });
                
                // Set initial stage
                this.currentStage = 'growth'; // Default to growth stage
                stageSelect.value = this.currentStage;
            }
            
            populatePersonaSelector() {
                const personas = this.dataClient.getAvailablePersonas();
                const personaSelect = document.getElementById('persona-select');
                
                personaSelect.innerHTML = '';
                Object.entries(personas).forEach(([id, persona]) => {
                    const option = document.createElement('option');
                    option.value = id;
                    option.textContent = persona.name;
                    if (id === this.currentPersona) {
                        option.selected = true;
                    }
                    personaSelect.appendChild(option);
                });
            }
            
            async switchPersona(personaId) {
                if (personaId === this.currentPersona) return;
                
                try {
                    await this.dataClient.switchPersona(personaId);
                    this.currentPersona = personaId;
                    this.updatePersonaMetadata();
                    this.updateDashboard();
                    this.animateSwitch();
                } catch (error) {
                    console.error('Failed to switch persona:', error);
                }
            }
            
            updatePersonaMetadata() {
                const personas = this.dataClient.getAvailablePersonas();
                const persona = personas[this.currentPersona];
                
                if (!persona) return;
                
                // Update persona info
                document.getElementById('current-persona-name').textContent = persona.name;
                document.getElementById('current-persona-description').textContent = persona.description || '';
                
                // Update Stripe products badges
                const productsContainer = document.getElementById('stripe-products');
                productsContainer.innerHTML = '';
                
                if (persona.stripe_products) {
                    persona.stripe_products.forEach(product => {
                        const badge = document.createElement('span');
                        badge.className = 'stripe-product-badge';
                        badge.textContent = product;
                        productsContainer.appendChild(badge);
                    });
                }
            }
            
            updateStageData() {
                console.log(`Stage changed to: ${this.currentStage}`);
                
                // Update the data client with new stage
                this.currentData = this.dataClient.updateStage(this.currentStage);
                
                // Refresh the dashboard with stage-appropriate data
                this.updateDashboard();
            }

            onPersonaSwitch(personaId) {
                // This is where designers can add custom logic when personas change
                console.log(`Dashboard switched to ${personaId}`);
                
                // Example: You could trigger custom animations, update charts, etc.
                this.animateSwitch();
            }

            animateSwitch() {
                // Simple animation to show the switch happened
                const content = document.getElementById('dashboard-content');
                content.style.opacity = '0.5';
                setTimeout(() => {
                    content.style.opacity = '1';
                }, 200);
            }

            showError(message) {
                document.getElementById('loading-state').innerHTML = `
                    <h3>Error</h3>
                    <p>${message}</p>
                `;
            }
        }

        // Initialize the dashboard when page loads
        document.addEventListener('DOMContentLoaded', () => {
            new DashboardPrototype();
        });
    </script>
</body>
</html>
