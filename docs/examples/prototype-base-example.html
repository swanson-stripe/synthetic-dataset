<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Stripe Dashboard Prototype - Multi-Persona</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: white;
            color: #1e293b;
            line-height: 1.6;
        }
        
        .prototype-header {
            background: white;
            padding: 1rem 2rem;
            display: flex;
            justify-content: flex-start;
            align-items: center;
        }
        
        /* Persona Selector Styles */
        .persona-selector-container {
            position: relative;
        }
        
        .persona-selector-button {
            display: flex;
            align-items: center;
            padding: 8px 12px;
            background: white;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            transition: all 0.15s ease;
            width: 260px;
            box-sizing: border-box;
        }
        
        .persona-selector-button:hover {
            background: #f8f9fa;
        }
        
        .persona-logo {
            width: 32px;
            height: 32px;
            border-radius: 6px;
            object-fit: cover;
            flex-shrink: 0;
            margin-right: 16px;
        }
        
        .persona-selector-text {
            flex: 1;
            text-align: left;
            min-width: 0;
        }
        
        .persona-name {
            font-size: 15px;
            font-weight: 500;
            color: #1a1a1a;
            margin: 0;
            line-height: 1.2;
        }
        
        .persona-description {
            display: none;
        }
        
        .dropdown-arrow {
            width: 12px;
            height: 12px;
            color: #666;
            transition: transform 0.15s ease;
            margin-left: 16px;
            flex-shrink: 0;
        }
        
        .persona-selector-button.open .dropdown-arrow {
            transform: rotate(180deg);
        }
        
        .dropdown-arrow.open {
            transform: rotate(180deg);
        }
        
        /* Popover Styles */
        .persona-popover {
            position: absolute;
            top: 100%;
            left: 0;
            right: 0;
            background: white;
            border-radius: 16px;
            box-shadow: 0 20px 25px -5px rgba(0, 0, 0, 0.1), 0 10px 10px -5px rgba(0, 0, 0, 0.04);
            z-index: 1000;
            margin-top: 8px;
            display: none;
            border: 1px solid #f0f0f0;
        }
        
        .persona-popover.show {
            display: block;
        }
        
        .popover-content {
            text-align: center;
        }
        
        .popover-logo-section {
            padding: 24px 24px 0;
            margin-bottom: 12px;
            text-align: center;
        }
        
        .popover-persona-logo {
            width: 48px;
            height: 48px;
            border-radius: 6px;
            object-fit: cover;
            display: block;
            margin: 0 auto;
        }
        
        .popover-title {
            font-size: 18px;
            font-weight: 600;
            color: #1a1a1a;
            margin-bottom: 8px;
            line-height: 1.2;
            padding: 0 24px;
        }
        
        .popover-description {
            font-size: 14px;
            color: #666;
            line-height: 1.3;
            margin-bottom: 16px;
            padding: 0 24px;
        }
        
        .stage-section {
            text-align: left;
            padding: 8px;
        }
        
        .stage-label {
            font-size: 14px;
            font-weight: 600;
            color: #666;
            margin-bottom: 12px;
        }
        
        .stage-options {
            display: flex;
            flex-direction: column;
            gap: 0;
        }
        
        .stage-option {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 8px 4px;
            cursor: pointer;
            font-size: 16px;
            color: #1a1a1a;
            transition: all 0.2s ease;
            border-bottom: none;
            border-radius: 6px;
        }
        
        .stage-option:hover {
            background: #F5F6F8;
        }
        
        .stage-text {
            font-weight: 400;
            font-size: 14px;
        }
        
        .stage-check {
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: #666;
            color: white;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 12px;
            font-weight: 600;
        }
        
        .stage-option:not(.selected) .stage-check {
            display: none;
        }
        
        .change-persona-btn {
            background: none;
            border: none;
            color: #1a1a1a;
            text-decoration: underline;
            cursor: pointer;
            font-size: 14px;
            margin-bottom: 16px;
            padding: 0;
            font-weight: 400;
        }
        
        .change-persona-btn:hover {
            color: #666;
        }
        
        .popover-divider {
            height: 1px;
            background: #e0e0e0;
            margin: 0;
        }
        
        /* Modal Styles */
        .persona-modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.5);
            z-index: 2000;
            align-items: center;
            justify-content: center;
        }
        
        .persona-modal.show {
            display: flex;
        }
        
        .modal-content {
            background: white;
            border-radius: 12px;
            padding: 0;
            max-width: 900px;
            width: 90%;
            max-height: 80vh;
            overflow: hidden;
            display: flex;
            flex-direction: row;
            height: 80vh;
        }
        
        .modal-header {
            margin-bottom: 1.5rem;
        }
        
        .modal-title {
            font-size: 1.25rem;
            font-weight: 600;
            color: #111827;
            margin-bottom: 0.5rem;
        }
        
        .modal-subtitle {
            font-size: 0.875rem;
            color: #6b7280;
        }
        
        .persona-list-panel {
            flex: 1;
            display: flex;
            flex-direction: column;
            padding: 2rem;
            height: 100%;
        }
        
        .personas-list {
            display: flex;
            flex-direction: column;
            gap: 0.5rem;
            flex: 1;
            overflow-y: auto;
            margin-bottom: 1rem;
        }
        
        /* Custom scrollbar styling */
        .personas-list::-webkit-scrollbar {
            width: 8px;
        }
        
        .personas-list::-webkit-scrollbar-track {
            background: transparent;
        }
        
        .personas-list::-webkit-scrollbar-thumb {
            background: #e5e7eb;
            border-radius: 4px;
        }
        
        .personas-list::-webkit-scrollbar-thumb:hover {
            background: #d1d5db;
        }
        
        .persona-details-panel::-webkit-scrollbar {
            width: 8px;
        }
        
        .persona-details-panel::-webkit-scrollbar-track {
            background: transparent;
        }
        
        .persona-details-panel::-webkit-scrollbar-thumb {
            background: #e5e7eb;
            border-radius: 4px;
        }
        
        .persona-details-panel::-webkit-scrollbar-thumb:hover {
            background: #d1d5db;
        }
        
        .modal-footer-left {
            margin-top: auto;
        }
        
        .persona-details-panel {
            flex: 1;
            padding: 2rem;
            border-left: 1px solid #e5e7eb;
            height: 100%;
            overflow-y: auto;
        }
        
        .persona-option {
            display: flex;
            align-items: center;
            gap: 0.75rem;
            padding: 8px;
            border: 2px solid transparent;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.2s ease;
            background: white;
        }
        
        .persona-option:hover {
            background: #f9fafb;
        }
        
        .persona-option.selected {
            border-color: #8b5cf6;
            background: white;
        }
        
        .persona-option-logo {
            width: 40px;
            height: 40px;
            border-radius: 8px;
            flex-shrink: 0;
        }
        
        /* Removed persona-option-info - simplified to just logo + name */
        
        .persona-option-name {
            font-size: 1rem;
            font-weight: 500;
            color: #111827;
        }
        
        /* Details Panel Styles */
        .persona-details-content {
            height: 100%;
        }
        
        .details-description {
            font-size: 1.125rem;
            font-weight: 400;
            color: #374151;
            margin-bottom: 2rem;
            line-height: 1.6;
        }
        
        .stripe-products-section {
            margin-top: 2rem;
        }
        
        .stripe-products-title {
            font-size: 1.125rem;
            font-weight: 600;
            color: #111827;
            margin-bottom: 1rem;
        }
        
        .stripe-products-list {
            list-style: none;
            padding: 0;
            margin: 0;
        }
        
        .stripe-products-list li {
            padding: 0.25rem 0;
            color: #374151;
            font-size: 1.125rem;
        }
        
        /* Removed persona-option-description - not needed in simplified list */
        
        /* Removed stripe-products CSS - using plain text bullets in details panel */
        
        .modal-footer {
            display: flex;
            justify-content: flex-end;
            gap: 0.75rem;
            border-top: 1px solid #e5e7eb;
            padding-top: 1.5rem;
        }
        
        .btn {
            padding: 0.75rem 1.5rem;
            border-radius: 6px;
            font-size: 0.875rem;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.2s ease;
            border: none;
        }
        
        .btn-secondary {
            background: #f9fafb;
            color: #374151;
            border: 1px solid #e5e7eb;
        }
        
        .btn-secondary:hover {
            background: #f3f4f6;
        }
        
        .btn-primary {
            background: #6366f1;
            color: white;
        }
        
        .btn-primary:hover {
            background: #4f46e5;
        }
        
        .modal-footer-left .btn {
            width: 100%;
            background: white;
            color: #374151;
            border: 1px solid #d1d5db;
        }
        
        .modal-footer-left .btn:hover {
            background: #f9fafb;
        }
        
        .prototype-main {
            padding: 2rem;
            max-width: 1200px;
            margin: 0 auto;
        }
        
        .metrics-grid {
            display: flex;
            flex-wrap: wrap;
            gap: 1.5rem;
            margin-bottom: 2rem;
        }
        
        .metric-card {
            padding: 16px;
            transition: all 0.2s ease;
            border-radius: 8px;
            width: fit-content;
            min-width: max-content;
        }
        
        .metric-card:hover {
            background: #f9fafb;
        }
        
        .metric-card.active {
            background: #f0f9ff;
            border: 2px solid #0ea5e9;
        }
        
        .metric-card.active:hover {
            background: #f0f9ff;
        }
        
        .metric-label {
            font-size: 0.875rem;
            color: #64748b;
            margin-bottom: 0.5rem;
        }
        
        .metric-value {
            font-size: 2rem;
            font-weight: 700;
            color: #0f172a;
        }
        
        .data-section {
            margin-bottom: 2rem;
            overflow: hidden;
        }
        
        .data-section-header {
            padding: 1rem 1.5rem;
        }
        
        .data-section-title {
            font-size: 1.125rem;
            font-weight: 600;
        }
        
        .data-table {
            width: 100%;
            border-collapse: collapse;
        }
        
        .data-table th {
            padding: 0.75rem 1.5rem;
            text-align: left;
            font-weight: 500;
            color: #374151;
        }
        
        .data-table td {
            padding: 0.75rem 1.5rem;
        }
        
        .status-badge {
            display: inline-block;
            padding: 0.25rem 0.5rem;
            border-radius: 4px;
            font-size: 0.75rem;
            font-weight: 500;
        }
        
        .status-succeeded {
            background: #dcfce7;
            color: #166534;
        }
        
        .status-failed {
            background: #fecaca;
            color: #991b1b;
        }
        
        .loading-state {
            display: none;
            text-align: center;
            padding: 2rem;
            color: #64748b;
        }
        
        .loading-state.active {
            display: block;
        }
        

        
        .chart-container {
            height: 240px;
            padding: 1rem;
            margin: 1rem 0;
            display: flex;
            align-items: center;
            justify-content: center;
            position: relative;
        }
        
        #revenue-chart {
            max-width: 100%;
            max-height: 200px;
            cursor: crosshair;
        }
        
        .chart-tooltip {
            position: absolute;
            background: rgba(0, 0, 0, 0.9);
            color: white;
            padding: 8px 12px;
            border-radius: 6px;
            font-size: 12px;
            font-weight: 500;
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.2s ease;
            z-index: 1000;
            min-width: 120px;
            text-align: center;
        }
        
        .chart-tooltip.visible {
            opacity: 1;
        }
        
        .chart-tooltip .tooltip-label {
            font-weight: 600;
            margin-bottom: 2px;
        }
        
        .chart-tooltip .tooltip-value {
            font-size: 14px;
            color: #a78bfa;
        }
    </style>
</head>
<body>
    <header class="prototype-header">
        <div class="persona-selector-container">
            <div class="persona-selector-button" id="persona-selector-btn">
                <img class="persona-logo" id="current-persona-logo" alt="Modaic">
                <div class="persona-selector-text">
                    <div class="persona-name" id="current-persona-name">Modaic</div>
                </div>
                <svg class="dropdown-arrow" id="dropdown-arrow" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 9l-7 7-7-7"></path>
                </svg>
            </div>
            
            <!-- Popover -->
            <div class="persona-popover" id="persona-popover">
                <div class="popover-content">
                    <div class="popover-logo-section">
                        <img class="popover-persona-logo" id="popover-persona-logo" alt="Modaic">
                    </div>
                    
                    <div class="popover-title" id="popover-persona-name">Modaic</div>
                    
                    <div class="popover-description" id="popover-persona-description">
                        E-commerce fashion retailer with global payment processing.
                    </div>
                    
                    <button class="change-persona-btn" id="change-persona-btn">Change</button>
                    
                    <div class="popover-divider"></div>
                    
                    <div class="stage-section">
                        <div class="stage-label">Stage</div>
                        
                        <div class="stage-options">
                            <div class="stage-option" data-stage="early">
                                <span class="stage-text">Early</span>
                                <span class="stage-check"></span>
                            </div>
                            <div class="stage-option selected" data-stage="growth">
                                <span class="stage-text">Growth</span>
                                <span class="stage-check">✓</span>
                            </div>
                            <div class="stage-option" data-stage="mature">
                                <span class="stage-text">Enterprise</span>
                                <span class="stage-check"></span>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </header>
    
    <!-- Persona Selection Modal -->
    <div class="persona-modal" id="persona-modal">
        <div class="modal-content">
            <div class="persona-list-panel">
                <div class="modal-header">
                    <h2 class="modal-title">Swap data scenarios</h2>
                    <p class="modal-subtitle">Choose which business persona dataset to use in your prototype.</p>
                </div>
                
                <div class="personas-list" id="personas-list">
                    <!-- Persona options will be populated here -->
                </div>
                
                <div class="modal-footer-left">
                    <button class="btn btn-primary" id="modal-done">Done</button>
                </div>
            </div>
            
            <div class="persona-details-panel">
                <div class="persona-details" id="persona-details">
                    <!-- Selected persona details will be shown here -->
                </div>
            </div>
        </div>
    </div>

    <main class="prototype-main">
        <div class="loading-state active" id="loading-state">
            <h3>Loading dashboard data...</h3>
            <p>Initializing with default business scenario</p>
        </div>

        <div id="dashboard-content" style="display: none;">
            <!-- Metrics Cards -->
            <div class="metrics-grid" id="metrics-cards">
                <!-- Metrics will be populated here -->
            </div>

            <!-- Charts Section -->
            <div class="data-section">
                <div class="data-section-header">
                    <h3 class="data-section-title" id="chart-title">Revenue Trends</h3>
                </div>
                <div class="chart-container" id="chart-container">
                    <svg id="revenue-chart" width="800" height="200"></svg>
                    <div class="chart-tooltip" id="chart-tooltip">
                        <div class="tooltip-label"></div>
                        <div class="tooltip-value"></div>
                    </div>
                </div>
            </div>

            <!-- Data Tables -->
            <div class="data-section">
                <div class="data-section-header">
                    <h3 class="data-section-title" id="primary-table-title">Transactions</h3>
                </div>
                <table class="data-table">
                    <thead>
                        <tr id="table-headers">
                            <!-- Headers will be populated based on persona -->
                        </tr>
                    </thead>
                    <tbody id="table-body">
                        <!-- Data will be populated here -->
                    </tbody>
                </table>
            </div>

            <!-- Secondary Data Section -->
            <div class="data-section" id="secondary-section">
                <div class="data-section-header">
                    <h3 class="data-section-title" id="secondary-table-title">Customers</h3>
                </div>
                <table class="data-table">
                    <thead>
                        <tr id="secondary-headers">
                            <!-- Headers will be populated based on persona -->
                        </tr>
                    </thead>
                    <tbody id="secondary-body">
                        <!-- Data will be populated here -->
                    </tbody>
                </table>
            </div>
        </div>
    </main>

    <!-- Include D3.js for charting -->
    <script src="https://d3js.org/d3.v7.min.js"></script>
    
    <!-- Include the data client and persona switcher -->
    <script src="../stripe-data-client.js"></script>


    <script>
        // This is what the designer gets - a fully functional prototype
        class DashboardPrototype {
            constructor() {
                this.dataClient = null;
                this.personaSwitcher = null;
                this.currentData = null;
                this.currentPersona = null;
                
                this.init();
            }

            init() {
                console.log('🎯 Initializing Dashboard Prototype...');
                
                try {
                    console.log('🔧 Creating StripeDataClient...');
                    
                    // Initialize data client with default persona (now synchronous)
                    try {
                        this.dataClient = new StripeDataClient({
                            defaultPersona: 'modaic' // Can be changed to any persona
                        });
                        console.log('✅ StripeDataClient constructor completed');
                    } catch (clientError) {
                        console.error('❌ Failed to create StripeDataClient:', clientError);
                        throw new Error(`Data client creation failed: ${clientError.message}`);
                    }

                    console.log('📊 Data client properties:', {
                        exists: !!this.dataClient,
                        currentPersona: this.dataClient?.currentPersona,
                        hasCurrentData: !!this.dataClient?.currentData,
                        currentDataKeys: this.dataClient?.currentData ? Object.keys(this.dataClient.currentData) : 'none',
                        hasCalculateMetrics: !!this.dataClient?.calculateMetrics,
                        hasAvailablePersonas: !!this.dataClient?.availablePersonas
                    });
                    
                    if (!this.dataClient?.currentData) {
                        console.error('❌ Data client currentData is null/undefined');
                        console.error('🔍 Data client state:', this.dataClient);
                        throw new Error('Data client failed to initialize with data');
                    }
                    
                    console.log('✅ Data loaded successfully!');

                    // Set current data and persona from the data client
                    this.currentData = this.dataClient.currentData;
                    this.currentPersona = this.dataClient.currentPersona;
                    
                    // Initialize navbar selectors AFTER confirming data is ready
                    this.initializeNavbarSelectors();

                    // Subscribe to data changes
                    this.dataClient.subscribe((data, personaId) => {
                        this.currentData = data;
                        this.currentPersona = personaId;
                        this.updatePersonaSelectorDisplay();
                        this.updateDashboard();
                    });

                    // Initial render (data and persona already set above)
                    console.log('🎭 Initial persona set to:', this.currentPersona);
                    console.log('📊 Initial data loaded:', !!this.currentData);
                    this.updatePersonaSelectorDisplay();
                    this.updateDashboard();

                } catch (error) {
                    console.error('Failed to initialize dashboard:', error);
                    this.showError('Failed to load dashboard data');
                }
            }

            updateDashboard() {
                console.log('🔄 Updating dashboard with data:', {
                    persona: this.currentPersona,
                    dataKeys: Object.keys(this.currentData || {}),
                    hasMetrics: !!this.dataClient?.calculateMetrics
                });
                
                this.hideLoading();
                this.updatePersonaIndicator();
                this.updateMetrics();
                this.updateChart();
                this.updateTables();
            }

            hideLoading() {
                document.getElementById('loading-state').classList.remove('active');
                document.getElementById('dashboard-content').style.display = 'block';
            }

            updateChart() {
                try {
                    // Clean up previous chart if exists
                    if (this.currentChart) {
                        this.destroyChart();
                    }
                    
                    const svg = d3.select('#revenue-chart');
                    if (svg.empty()) {
                        console.log('❌ Chart SVG not found');
                        return;
                    }
                    
                    const metrics = this.dataClient?.calculateMetrics() || [];
                    
                    if (metrics.length === 0) {
                        console.log('❌ No metrics available for chart');
                        this.drawEmptyChart(svg);
                        return;
                    }
                    
                    // Use the first metric for the time series
                    const primaryMetric = metrics[0];
                    console.log('📈 Drawing D3 chart for metric:', primaryMetric.label);
                    
                    // Update chart title
                    const chartTitle = document.getElementById('chart-title');
                    if (chartTitle) {
                        chartTitle.textContent = `${primaryMetric.label} Trends`;
                    }
                    
                    // Generate time series data for the past 12 months
                    const timeSeriesData = this.generateTimeSeriesData(primaryMetric, this.currentPersona);
                    
                    // Initialize D3 chart
                    this.initializeD3Chart(svg, timeSeriesData, primaryMetric);
                    
                } catch (error) {
                    console.error('Error updating chart:', error);
                }
            }
            
            initializeD3Chart(svg, data, metric) {
                // Chart dimensions and margins
                const margin = { top: 20, right: 40, bottom: 40, left: 60 };
                const width = 800 - margin.left - margin.right;
                const height = 200 - margin.top - margin.bottom;
                
                // Clear previous chart
                svg.selectAll("*").remove();
                
                // Create main group
                const g = svg.append("g")
                    .attr("transform", `translate(${margin.left},${margin.top})`);
                
                // Set up scales
                const xScale = d3.scaleTime()
                    .domain(d3.extent(data.dates))
                    .range([0, width]);
                
                const yScale = d3.scaleLinear()
                    .domain(d3.extent(data.values))
                    .nice()
                    .range([height, 0]);
                
                // Create line generator
                const line = d3.line()
                    .x(d => xScale(d.date))
                    .y(d => yScale(d.value))
                    .curve(d3.curveMonotoneX);
                
                // Prepare data for line
                const lineData = data.dates.map((date, i) => ({
                    date: date,
                    value: data.values[i]
                }));
                
                // Add X axis
                const xAxis = g.append("g")
                    .attr("transform", `translate(0,${height})`)
                    .call(d3.axisBottom(xScale)
                        .ticks(d3.timeMonth.every(2))
                        .tickFormat(d3.timeFormat("%b %y")));
                
                // Style X axis
                xAxis.selectAll("text")
                    .style("font-size", "11px")
                    .style("fill", "#64748b");
                    
                xAxis.selectAll("line")
                    .style("stroke", "#e2e8f0");
                    
                xAxis.select(".domain")
                    .style("stroke", "#e2e8f0");
                
                // Add Y axis
                const yAxis = g.append("g")
                    .call(d3.axisLeft(yScale)
                        .ticks(5)
                        .tickFormat(d => this.formatD3AxisValue(d, metric)));
                
                // Style Y axis
                yAxis.selectAll("text")
                    .style("font-size", "11px")
                    .style("fill", "#64748b");
                    
                yAxis.selectAll("line")
                    .style("stroke", "#e2e8f0");
                    
                yAxis.select(".domain")
                    .style("stroke", "#e2e8f0");
                
                // Add grid lines
                g.selectAll(".grid-line-x")
                    .data(xScale.ticks(d3.timeMonth.every(2)))
                    .enter()
                    .append("line")
                    .attr("class", "grid-line-x")
                    .attr("x1", d => xScale(d))
                    .attr("x2", d => xScale(d))
                    .attr("y1", 0)
                    .attr("y2", height)
                    .style("stroke", "#e2e8f0")
                    .style("stroke-width", 1);
                
                g.selectAll(".grid-line-y")
                    .data(yScale.ticks(5))
                    .enter()
                    .append("line")
                    .attr("class", "grid-line-y")
                    .attr("x1", 0)
                    .attr("x2", width)
                    .attr("y1", d => yScale(d))
                    .attr("y2", d => yScale(d))
                    .style("stroke", "#e2e8f0")
                    .style("stroke-width", 1);
                
                // Add the line
                g.append("path")
                    .datum(lineData)
                    .attr("class", "line")
                    .attr("d", line)
                    .style("fill", "none")
                    .style("stroke", "#635bff")
                    .style("stroke-width", 3);
                
                // Add data points (sample every 7 days for performance)
                const sampledData = lineData.filter((d, i) => i % 7 === 0 || i === 0 || i === lineData.length - 1);
                
                g.selectAll(".dot")
                    .data(sampledData)
                    .enter()
                    .append("circle")
                    .attr("class", "dot")
                    .attr("cx", d => xScale(d.date))
                    .attr("cy", d => yScale(d.value))
                    .attr("r", 3)
                    .style("fill", "#635bff");
                
                // Add tooltip functionality
                this.addD3Tooltip(g, lineData, xScale, yScale, metric, width, height);
                
                // Store for cleanup
                this.currentChart = { svg, g, xScale, yScale, lineData, metric };
            }
            
            addD3Tooltip(g, lineData, xScale, yScale, metric, width, height) {
                // Create bisector for finding closest data point
                const bisect = d3.bisector(d => d.date).left;
                
                // Create invisible overlay for mouse events
                const overlay = g.append("rect")
                    .attr("class", "overlay")
                    .attr("width", width)
                    .attr("height", height)
                    .style("fill", "none")
                    .style("pointer-events", "all");
                
                // Tooltip elements
                const tooltip = d3.select('#chart-tooltip');
                const focus = g.append("g")
                    .attr("class", "focus")
                    .style("display", "none");
                
                focus.append("circle")
                    .attr("r", 5)
                    .style("fill", "#635bff")
                    .style("stroke", "white")
                    .style("stroke-width", 2);
                
                focus.append("line")
                    .attr("class", "x-hover-line")
                    .style("stroke", "#635bff")
                    .style("stroke-width", 1)
                    .style("stroke-dasharray", "3,3");
                
                overlay.on("mouseover", () => focus.style("display", null))
                    .on("mouseout", () => {
                        focus.style("display", "none");
                        tooltip.style("opacity", 0).classed("visible", false);
                    })
                    .on("mousemove", (event) => {
                        const mouseX = d3.pointer(event)[0];
                        const x0 = xScale.invert(mouseX);
                        const i = bisect(lineData, x0, 1);
                        const d0 = lineData[i - 1];
                        const d1 = lineData[i];
                        
                        if (!d0 || !d1) return;
                        
                        const d = x0 - d0.date > d1.date - x0 ? d1 : d0;
                        
                        focus.attr("transform", `translate(${xScale(d.date)}, ${yScale(d.value)})`);
                        
                        focus.select(".x-hover-line")
                            .attr("y1", -yScale(d.value))
                            .attr("y2", height - yScale(d.value));
                        
                        // Update tooltip
                        const tooltipLabel = tooltip.select('.tooltip-label');
                        const tooltipValue = tooltip.select('.tooltip-value');
                        
                        tooltipLabel.text(d.date.toLocaleDateString('en-US', { 
                            month: 'short', 
                            day: 'numeric',
                            year: 'numeric'
                        }));
                        tooltipValue.text(this.formatTooltipValue(d.value, metric));
                        
                        // Position tooltip
                        const chartContainer = document.getElementById('chart-container');
                        const containerRect = chartContainer.getBoundingClientRect();
                        const svgRect = g.node().getBoundingClientRect();
                        
                        const tooltipX = xScale(d.date) + 60; // Account for left margin
                        const tooltipY = yScale(d.value) + 20; // Account for top margin
                        
                        tooltip
                            .style("left", `${tooltipX}px`)
                            .style("top", `${tooltipY}px`)
                            .style("opacity", 1)
                            .classed("visible", true);
                    });
            }
            
            formatD3AxisValue(value, metric) {
                // Handle rate metrics (values between 0-1)
                if (value <= 1 && value >= 0 && metric && this.isRateMetric(metric)) {
                    return new Intl.NumberFormat('en-US', {
                        style: 'percent',
                        minimumFractionDigits: 0,
                        maximumFractionDigits: 1
                    }).format(value);
                }
                
                // Handle large numbers
                if (value >= 1000000) {
                    return (value / 1000000).toFixed(1) + 'M';
                } else if (value >= 1000) {
                    return (value / 1000).toFixed(0) + 'K';
                } else if (value >= 1) {
                    return value.toFixed(0);
                } else {
                    return value.toFixed(2);
                }
            }
            

            
            addChartEventListeners() {
                const canvas = this.currentChartData.canvas;
                
                this.chartMouseMoveHandler = (e) => this.handleChartMouseMove(e);
                this.chartMouseLeaveHandler = (e) => this.handleChartMouseLeave(e);
                
                canvas.addEventListener('mousemove', this.chartMouseMoveHandler);
                canvas.addEventListener('mouseleave', this.chartMouseLeaveHandler);
            }
            
            removeChartEventListeners() {
                const canvas = this.currentChartData?.canvas;
                if (!canvas) return;
                
                if (this.chartMouseMoveHandler) {
                    canvas.removeEventListener('mousemove', this.chartMouseMoveHandler);
                }
                if (this.chartMouseLeaveHandler) {
                    canvas.removeEventListener('mouseleave', this.chartMouseLeaveHandler);
                }
            }
            
            handleChartMouseMove(e) {
                const canvas = this.currentChartData.canvas;
                const rect = canvas.getBoundingClientRect();
                const mouseX = e.clientX - rect.left;
                const mouseY = e.clientY - rect.top;
                
                // Find the closest data point
                let closestPoint = null;
                let minDistance = Infinity;
                
                this.currentChartData.dataPoints.forEach(point => {
                    const distance = Math.sqrt(Math.pow(mouseX - point.x, 2) + Math.pow(mouseY - point.y, 2));
                    if (distance < minDistance && distance < 20) { // 20px hover radius
                        minDistance = distance;
                        closestPoint = point;
                    }
                });
                
                if (closestPoint) {
                    this.showTooltip(closestPoint, e.clientX, e.clientY);
                    this.currentChartData.hoverPoint = closestPoint;
                    this.drawInteractiveChart(); // Redraw with hover highlight
                } else {
                    this.hideTooltip();
                    this.currentChartData.hoverPoint = null;
                    this.drawInteractiveChart(); // Redraw without hover
                }
            }
            
            handleChartMouseLeave(e) {
                this.hideTooltip();
                this.currentChartData.hoverPoint = null;
                this.drawInteractiveChart();
            }
            
            drawHoverPoint(point) {
                const { ctx } = this.currentChartData;
                
                // Draw larger highlighted point
                ctx.fillStyle = '#4f46e5';
                ctx.beginPath();
                ctx.arc(point.x, point.y, 6, 0, 2 * Math.PI);
                ctx.fill();
                
                // Draw white center
                ctx.fillStyle = 'white';
                ctx.beginPath();
                ctx.arc(point.x, point.y, 3, 0, 2 * Math.PI);
                ctx.fill();
                
                // Draw vertical line to x-axis
                ctx.strokeStyle = '#e2e8f0';
                ctx.lineWidth = 1;
                ctx.setLineDash([3, 3]);
                ctx.beginPath();
                ctx.moveTo(point.x, point.y);
                ctx.lineTo(point.x, this.currentChartData.padding + this.currentChartData.chartHeight);
                ctx.stroke();
                ctx.setLineDash([]);
            }
            
            showTooltip(point, clientX, clientY) {
                const tooltip = document.getElementById('chart-tooltip');
                const container = document.getElementById('chart-container');
                
                if (!tooltip || !container) return;
                
                const containerRect = container.getBoundingClientRect();
                const tooltipX = clientX - containerRect.left;
                const tooltipY = clientY - containerRect.top - 60;
                
                // Format the value based on metric type
                const formattedValue = this.formatTooltipValue(point.value, this.currentChartData.metric);
                
                tooltip.querySelector('.tooltip-label').textContent = point.label;
                tooltip.querySelector('.tooltip-value').textContent = formattedValue;
                
                tooltip.style.left = `${Math.max(10, Math.min(tooltipX - 60, container.clientWidth - 130))}px`;
                tooltip.style.top = `${Math.max(10, tooltipY)}px`;
                tooltip.classList.add('visible');
            }
            
            hideTooltip() {
                const tooltip = document.getElementById('chart-tooltip');
                if (tooltip) {
                    tooltip.classList.remove('visible');
                }
            }
            
            formatTooltipValue(value, metric) {
                // Use the rate detection logic for consistent formatting
                if (this.isRateMetric(metric)) {
                    // Percentage formatting for rates
                    return new Intl.NumberFormat('en-US', {
                        style: 'percent',
                        minimumFractionDigits: 2,
                        maximumFractionDigits: 2
                    }).format(value);
                } else {
                    // Determine format based on metric label for non-rates
                    const label = metric.label.toLowerCase();
                    
                    if (label.includes('revenue') || label.includes('mrr') || label.includes('arr') || 
                        label.includes('volume') || label.includes('raised') || label.includes('collected')) {
                        // Currency formatting
                        return new Intl.NumberFormat('en-US', {
                            style: 'currency',
                            currency: 'USD',
                            minimumFractionDigits: 0,
                            maximumFractionDigits: 0
                        }).format(value / 100);
                    } else {
                        // Number formatting
                        return new Intl.NumberFormat('en-US').format(value);
                    }
                }
            }
            
            generateTimeSeriesData(metric, personaId) {
                // Generate 12 months of daily data (365 days)
                const dates = [];
                const values = [];
                const now = new Date();
                
                // Current value must match exactly
                const currentValue = metric.rawValue || 0;
                
                // Detect if this is a rate/percentage metric
                const isRateMetric = this.isRateMetric(metric);
                console.log(`📊 Generating daily time series for ${metric.label}, isRate: ${isRateMetric}, currentValue: ${currentValue}`);
                
                // Generate 365 days of data (12 months)
                for (let i = 364; i >= 0; i--) {
                    const date = new Date(now.getTime() - (i * 24 * 60 * 60 * 1000));
                    dates.push(date);
                    
                    if (i === 0) {
                        // Today (current) - use exact current value
                        values.push(currentValue);
                    } else {
                        // Historical days - work backwards from current value
                        let value;
                        
                        if (isRateMetric) {
                            // For rates, use smaller daily variations
                            const dailyVariation = 0.95 + Math.random() * 0.1; // ±5% daily variation
                            const monthsAgo = i / 30.44; // Average days per month
                            const trendFactor = 1 - (monthsAgo * 0.015); // 1.5% improvement per month
                            const seasonality = 1 + 0.05 * Math.sin((i / 365) * 2 * Math.PI); // 5% seasonal variation
                            
                            value = currentValue * dailyVariation * trendFactor * seasonality;
                            
                            // Ensure rates stay within reasonable bounds (0.1% to 99%)
                            value = Math.max(0.001, Math.min(0.99, value));
                        } else {
                            // For volume metrics, use growth patterns with daily variation
                            const monthsAgo = Math.floor(i / 30.44);
                            const stageMultiplier = this.getStageGrowthPattern(monthsAgo, this.currentStage);
                            const businessGrowth = this.getBusinessGrowthPattern(monthsAgo, personaId);
                            const dailyVariation = 0.9 + Math.random() * 0.2; // ±10% daily variation
                            const weekdayFactor = this.getWeekdayFactor(date); // Business patterns
                            
                            value = Math.floor(currentValue * stageMultiplier * businessGrowth * dailyVariation * weekdayFactor);
                        }
                        
                        values.push(Math.max(0, value));
                    }
                }
                
                return { dates, values, label: metric.label };
            }
            
            getWeekdayFactor(date) {
                const day = date.getDay(); // 0 = Sunday, 6 = Saturday
                // Business metrics typically higher on weekdays
                if (day === 0 || day === 6) {
                    return 0.7; // Weekend factor
                } else if (day === 1 || day === 5) {
                    return 0.9; // Monday/Friday factor
                } else {
                    return 1.0; // Tuesday-Thursday peak
                }
            }
            
            isRateMetric(metric) {
                const label = metric.label.toLowerCase();
                return label.includes('rate') || 
                       label.includes('percent') || 
                       label.includes('conversion') ||
                       label.includes('success') ||
                       label.includes('retention') ||
                       label.includes('margin') ||
                       label.includes('churn') ||
                       (metric.rawValue > 0 && metric.rawValue <= 1); // Decimal between 0-1 likely a rate
            }
            
            getStageGrowthPattern(monthsAgo, stage) {
                // Different growth patterns based on business stage
                switch (stage) {
                    case 'early':
                        // Exponential growth from very small
                        return Math.pow(1.25, 11 - monthsAgo) * 0.1;
                    case 'growth':
                        // Steady growth
                        return 0.3 + (11 - monthsAgo) * 0.08;
                    case 'mature':
                        // Slower, steady growth
                        return 0.7 + (11 - monthsAgo) * 0.04;
                    default:
                        return 0.5 + (11 - monthsAgo) * 0.05;
                }
            }
            
            getBusinessGrowthPattern(monthsAgo, personaId) {
                // Seasonal patterns based on business type
                const seasonalMultipliers = {
                    'techstyle': [0.8, 0.9, 1.1, 1.2, 1.1, 0.9, 0.8, 0.9, 1.0, 1.1, 1.3, 1.4], // Fashion peaks in Q4
                    'edutech': [1.2, 1.0, 0.9, 0.8, 0.7, 0.6, 0.7, 1.3, 1.4, 1.2, 1.0, 0.9], // Education peaks in fall
                    'givehope': [0.9, 0.8, 0.9, 1.0, 1.0, 0.9, 0.8, 0.9, 1.0, 1.1, 1.2, 1.5], // Charity peaks in December
                    'fitstream': [1.4, 1.3, 1.1, 1.0, 1.1, 1.0, 0.9, 0.9, 1.0, 1.1, 1.2, 1.1], // Fitness peaks in January
                    'localbites': [0.9, 0.9, 1.0, 1.1, 1.2, 1.3, 1.2, 1.1, 1.0, 1.0, 1.1, 1.0] // Food delivery peaks in summer
                };
                
                const pattern = seasonalMultipliers[personaId] || [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1];
                const monthIndex = (11 - monthsAgo) % 12;
                return pattern[monthIndex];
            }
            
            // Cleanup method to remove chart
            destroyChart() {
                if (this.currentChart) {
                    // Hide tooltip
                    d3.select('#chart-tooltip').style("opacity", 0).classed("visible", false);
                    
                    // Clear SVG
                    this.currentChart.svg.selectAll("*").remove();
                    this.currentChart = null;
                }
            }
            
            drawEmptyChart(svg) {
                svg.selectAll("*").remove();
                
                const g = svg.append("g")
                    .attr("transform", "translate(60, 20)");
                    
                g.append("text")
                    .attr("x", 400)
                    .attr("y", 100)
                    .attr("text-anchor", "middle")
                    .style("fill", "#64748b")
                    .style("font-size", "14px")
                    .style("font-family", "-apple-system, BlinkMacSystemFont, sans-serif")
                    .text("No data available");
            }
            
            drawGrid(ctx, canvas, padding, chartWidth, chartHeight, minValue, maxValue, dates) {
                ctx.strokeStyle = '#e2e8f0';
                ctx.lineWidth = 1;
                ctx.fillStyle = '#64748b';
                ctx.font = '11px -apple-system, BlinkMacSystemFont, sans-serif';
                
                // Draw horizontal grid lines and Y-axis labels
                const ySteps = 5;
                for (let i = 0; i <= ySteps; i++) {
                    const y = padding + (i / ySteps) * chartHeight;
                    const value = maxValue - (i / ySteps) * (maxValue - minValue);
                    
                    // Grid line
                    ctx.beginPath();
                    ctx.moveTo(padding, y);
                    ctx.lineTo(padding + chartWidth, y);
                    ctx.stroke();
                    
                    // Y-axis label
                    const labelText = this.formatChartAxisValue(value);
                    ctx.fillText(labelText, 5, y + 4);
                }
                
                // Draw X-axis labels (monthly markers for daily data)
                const monthlyIndices = this.getMonthlyAxisIndices(dates);
                
                for (const { index, date } of monthlyIndices) {
                    const x = padding + (index / (dates.length - 1)) * chartWidth;
                    const y = padding + chartHeight + 15;
                    
                    // Vertical grid line at month boundaries
                    ctx.beginPath();
                    ctx.moveTo(x, padding);
                    ctx.lineTo(x, padding + chartHeight);
                    ctx.stroke();
                    
                    // Month label
                    ctx.save();
                    ctx.textAlign = 'center';
                    const monthLabel = date.toLocaleDateString('en-US', { month: 'short', year: '2-digit' });
                    ctx.fillText(monthLabel, x, y);
                    ctx.restore();
                }
            }
            
            getMonthlyAxisIndices(dates) {
                const monthlyIndices = [];
                let lastMonth = -1;
                
                dates.forEach((date, index) => {
                    const currentMonth = date.getMonth();
                    const currentYear = date.getFullYear();
                    
                    // Add index for first day of each month
                    if (currentMonth !== lastMonth) {
                        monthlyIndices.push({ index, date });
                        lastMonth = currentMonth;
                    }
                });
                
                // Ensure we don't have too many labels (max 6 months shown)
                if (monthlyIndices.length > 6) {
                    const step = Math.ceil(monthlyIndices.length / 6);
                    return monthlyIndices.filter((_, index) => index % step === 0);
                }
                
                return monthlyIndices;
            }
            
            formatChartAxisValue(value) {
                // Handle rate metrics (values between 0-1)
                if (value <= 1 && value >= 0 && this.currentChartData?.metric && this.isRateMetric(this.currentChartData.metric)) {
                    return new Intl.NumberFormat('en-US', {
                        style: 'percent',
                        minimumFractionDigits: 0,
                        maximumFractionDigits: 1
                    }).format(value);
                }
                
                // Handle large numbers
                if (value >= 1000000) {
                    return (value / 1000000).toFixed(1) + 'M';
                } else if (value >= 1000) {
                    return (value / 1000).toFixed(0) + 'K';
                } else if (value >= 1) {
                    return value.toFixed(0);
                } else {
                    return value.toFixed(2);
                }
            }
            
            formatChartValue(value) {
                if (value >= 1000000) {
                    return (value / 1000000).toFixed(1) + 'M';
                } else if (value >= 1000) {
                    return (value / 1000).toFixed(0) + 'K';
                } else {
                    return value.toFixed(0);
                }
            }
            
            drawEmptyChart(ctx, canvas) {
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                ctx.fillStyle = '#64748b';
                ctx.font = '14px -apple-system, BlinkMacSystemFont, sans-serif';
                ctx.textAlign = 'center';
                ctx.fillText('No data available', canvas.width / 2, canvas.height / 2);
            }

            updatePersonaIndicator() {
                const personas = this.dataClient.getAvailablePersonas();
                const current = personas[this.currentPersona];
                
                // Legacy code removed - persona info now handled by updatePersonaMetadata()
            }



            updateMetrics() {
                try {
                    const metrics = this.dataClient?.calculateMetrics() || [];
                    console.log('📈 Calculated metrics:', metrics);
                    
                    const container = document.getElementById('metrics-cards');
                    if (!container) {
                        console.error('❌ Metrics container not found');
                        return;
                    }
                    
                    if (metrics.length === 0) {
                        console.warn('⚠️ No metrics calculated, using fallback');
                        container.innerHTML = `
                            <div class="metric-card">
                                <div class="metric-label">Total Revenue</div>
                                <div class="metric-value">$185,000,000</div>
                            </div>
                            <div class="metric-card">
                                <div class="metric-label">Success Rate</div>
                                <div class="metric-value">98.1%</div>
                            </div>
                            <div class="metric-card">
                                <div class="metric-label">Customers</div>
                                <div class="metric-value">75,000</div>
                            </div>
                            <div class="metric-card">
                                <div class="metric-label">Avg Order</div>
                                <div class="metric-value">$123</div>
                            </div>
                        `;
                        return;
                    }
                    
                    // Debug: Log each metric before rendering
                    metrics.forEach((metric, i) => {
                        console.log(`📊 Metric ${i}:`, metric);
                    });
                    
                    const html = metrics.map((metric, index) => `
                        <div class="metric-card" data-metric-index="${index}" style="cursor: pointer;">
                            <div class="metric-label">${metric.label || 'Unknown'}</div>
                            <div class="metric-value">${metric.value || 'No Value'}</div>
                        </div>
                    `).join('');
                    
                    console.log('🖼️ Generated HTML:', html);
                    container.innerHTML = html;
                    
                    // Add click handlers to metric cards
                    this.addMetricClickHandlers(metrics);
                } catch (error) {
                    console.error('❌ Error updating metrics:', error);
                }
            }
            
            addMetricClickHandlers(metrics) {
                const metricCards = document.querySelectorAll('.metric-card');
                metricCards.forEach((card, index) => {
                    card.addEventListener('click', () => {
                        console.log(`📊 Metric card ${index} clicked:`, metrics[index]);
                        
                        // Remove active state from all cards
                        metricCards.forEach(c => c.classList.remove('active'));
                        
                        // Add active state to clicked card
                        card.classList.add('active');
                        
                        // Update chart to show this metric's time series
                        this.updateChartForMetric(metrics[index], index);
                    });
                });
                
                // Set first metric as active by default
                if (metricCards.length > 0) {
                    metricCards[0].classList.add('active');
                }
            }
            
            updateChartForMetric(metric, metricIndex) {
                try {
                    const svg = d3.select('#revenue-chart');
                    if (svg.empty()) return;
                    
                    console.log('📈 Updating D3 chart for metric:', metric.label);
                    
                    // Update chart title
                    const chartTitle = document.getElementById('chart-title');
                    if (chartTitle) {
                        chartTitle.textContent = `${metric.label} Trends`;
                    }
                    
                    // Clean up previous chart
                    if (this.currentChart) {
                        this.destroyChart();
                    }
                    
                    // Generate time series data for this specific metric
                    const timeSeriesData = this.generateTimeSeriesData(metric, this.currentPersona);
                    
                    // Initialize D3 chart with the new data
                    this.initializeD3Chart(svg, timeSeriesData, metric);
                    
                } catch (error) {
                    console.error('Error updating chart for metric:', error);
                }
            }

            updateTables() {
                console.log('📋 Updating tables for persona:', this.currentPersona);
                console.log('📋 Current data for tables:', this.currentData);
                try {
                    // Update primary table based on persona
                    this.updatePrimaryTable();
                    this.updateSecondaryTable();
                } catch (error) {
                    console.error('❌ Error updating tables:', error);
                }
            }

            updatePrimaryTable() {
                const persona = this.currentPersona;
                let data, headers, title;

                console.log(`🔧 updatePrimaryTable for ${persona}:`, {
                    currentData: this.currentData,
                    dataKeys: Object.keys(this.currentData || {}),
                    payments: this.currentData?.payments?.length,
                    customers: this.currentData?.customers?.length,
                    connected_accounts: this.currentData?.connected_accounts?.length,
                    paymentsExists: !!this.currentData?.payments,
                    firstPayment: this.currentData?.payments?.[0]
                });

                // All personas now use standardized Stripe objects - primarily payments
                switch (persona) {
                    case 'modaic':
                        data = this.currentData.payments?.slice(0, 10) || [];
                        headers = ['Payment ID', 'Amount', 'Status', 'Currency', 'Customer'];
                        title = 'Recent Payments';
                        break;
                    case 'mindora':
                        data = this.currentData.payments?.slice(0, 10) || [];
                        headers = ['Payment ID', 'Amount', 'Status', 'Course', 'Customer'];
                        title = 'Course Payments';
                        break;
                    case 'keynest':
                        data = this.currentData.payments?.slice(0, 10) || [];
                        headers = ['Payment ID', 'Amount', 'Status', 'Property', 'Customer'];
                        title = 'Rent Payments';
                        break;
                    case 'pulseon':
                        data = this.currentData.payments?.slice(0, 10) || [];
                        headers = ['Payment ID', 'Amount', 'Status', 'Plan', 'Customer'];
                        title = 'Membership Payments';
                        break;
                    case 'fluxly':
                        data = this.currentData.payments?.slice(0, 10) || [];
                        headers = ['Payment ID', 'Amount', 'Status', 'Content', 'Customer'];
                        title = 'Content Purchases';
                        break;
                    case 'brightfund':
                        data = this.currentData.payments?.slice(0, 10) || [];
                        headers = ['Payment ID', 'Amount', 'Status', 'Campaign', 'Customer'];
                        title = 'Donations';
                        break;
                    case 'procura':
                        data = this.currentData.payments?.slice(0, 10) || [];
                        headers = ['Payment ID', 'Amount', 'Status', 'PO Number', 'Customer'];
                        title = 'Medical Supply Payments';
                        break;
                    case 'stratus':
                        data = this.currentData.payments?.slice(0, 10) || [];
                        headers = ['Payment ID', 'Amount', 'Status', 'Plan', 'Customer'];
                        title = 'SaaS Payments';
                        break;
                    case 'forksy':
                        data = this.currentData.payments?.slice(0, 10) || [];
                        headers = ['Payment ID', 'Amount', 'Status', 'Restaurant', 'Customer'];
                        title = 'Food Orders';
                        break;
                    default:
                        data = [];
                        headers = ['ID', 'Data', 'Status'];
                        title = 'Data Table';
                }

                document.getElementById('primary-table-title').textContent = title;
                this.populateTable('table-headers', 'table-body', headers, data, persona, 'primary');
            }

            updateSecondaryTable() {
                const persona = this.currentPersona;
                let data, headers, title;

                console.log(`🔧 updateSecondaryTable for ${persona}:`, {
                    currentData: this.currentData,
                    dataKeys: Object.keys(this.currentData || {}),
                    payments: this.currentData?.payments?.length,
                    customers: this.currentData?.customers?.length,
                    connected_accounts: this.currentData?.connected_accounts?.length,
                    customersExists: !!this.currentData?.customers,
                    connectedAccountsExists: !!this.currentData?.connected_accounts,
                    firstCustomer: this.currentData?.customers?.[0],
                    firstConnectedAccount: this.currentData?.connected_accounts?.[0]
                });

                // Show customers for most personas, connected_accounts for marketplace personas
                switch (persona) {
                    case 'modaic':
                        data = this.currentData.customers?.slice(0, 10) || [];
                        headers = ['Customer ID', 'Email', 'Name', 'Total Spend', 'Country'];
                        title = 'Top Customers';
                        break;
                    case 'mindora':
                        data = this.currentData.connected_accounts?.slice(0, 10) || [];
                        headers = ['Account ID', 'Instructor Name', 'Expertise', 'Rating', 'Students'];
                        title = 'Top Instructors';
                        break;
                    case 'keynest':
                        data = this.currentData.connected_accounts?.slice(0, 10) || [];
                        headers = ['Account ID', 'Landlord Name', 'Properties', 'Experience', 'Portfolio Value'];
                        title = 'Landlords';
                        break;
                    case 'pulseon':
                        data = this.currentData.customers?.slice(0, 10) || [];
                        headers = ['Customer ID', 'Email', 'Fitness Level', 'Goals', 'Check-ins'];
                        title = 'Members';
                        break;
                    case 'fluxly':
                        data = this.currentData.connected_accounts?.slice(0, 10) || [];
                        headers = ['Account ID', 'Creator Name', 'Category', 'Followers', 'Content Count'];
                        title = 'Top Creators';
                        break;
                    case 'brightfund':
                        data = this.currentData.customers?.slice(0, 10) || [];
                        headers = ['Customer ID', 'Email', 'Donor Type', 'Total Donated', 'Frequency'];
                        title = 'Top Donors';
                        break;
                    case 'procura':
                        data = this.currentData.customers?.slice(0, 10) || [];
                        headers = ['Customer ID', 'Hospital Name', 'Facility Type', 'Credit Limit', 'Total Spend'];
                        title = 'Healthcare Clients';
                        break;
                    case 'stratus':
                        data = this.currentData.customers?.slice(0, 10) || [];
                        headers = ['Customer ID', 'Company Name', 'Industry', 'Employee Count', 'Total Spend'];
                        title = 'Enterprise Customers';
                        break;
                    case 'forksy':
                        data = this.currentData.connected_accounts?.slice(0, 10) || [];
                        headers = ['Account ID', 'Business Name', 'Type', 'Rating', 'Total Orders'];
                        title = 'Restaurant Partners';
                        break;

                    default:
                        data = [];
                        headers = ['ID', 'Data'];
                        title = 'Secondary Data';
                }

                document.getElementById('secondary-table-title').textContent = title;
                this.populateTable('secondary-headers', 'secondary-body', headers, data, persona, 'secondary');
            }

            populateTable(headersId, bodyId, headers, data, persona, tableType) {
                console.log(`🔧 populateTable called for ${persona} ${tableType}:`, {
                    headersId, bodyId, headers, 
                    dataLength: data?.length, 
                    data: data?.slice(0, 2) // Show first 2 items for debugging
                });
                
                // Populate headers
                document.getElementById(headersId).innerHTML = headers.map(h => `<th>${h}</th>`).join('');
                
                // Populate body
                const tbody = document.getElementById(bodyId);
                if (!data || data.length === 0) {
                    tbody.innerHTML = '<tr><td colspan="5">No data available</td></tr>';
                    console.warn(`⚠️ No data for ${persona} ${tableType} table`);
                    return;
                }
                
                try {
                    tbody.innerHTML = data.map((item, index) => {
                        try {
                            const row = this.formatTableRow(item, persona, tableType);
                            if (!row) {
                                console.error(`❌ formatTableRow returned empty for ${persona} ${tableType} item ${index}:`, item);
                                return '<tr><td colspan="5">Row formatting error</td></tr>';
                            }
                            return `<tr>${row}</tr>`;
                        } catch (error) {
                            console.error(`❌ Error formatting ${persona} ${tableType} row ${index}:`, error, item);
                            return '<tr><td colspan="5">Row error</td></tr>';
                        }
                    }).join('');
                } catch (error) {
                    console.error(`❌ Error populating ${persona} ${tableType} table:`, error);
                    tbody.innerHTML = '<tr><td colspan="5">Table error</td></tr>';
                }
            }

            formatTableRow(item, persona, tableType) {
                console.log(`🔧 formatTableRow: ${persona} ${tableType}`, { item, keys: Object.keys(item || {}) });
                
                if (tableType === 'primary') {
                    // All primary tables show payments with persona-specific metadata
                    const result = this.formatPaymentRow(item, persona);
                    console.log(`🔧 formatPaymentRow result for ${persona}:`, result);
                    return result;
                } else {
                    // Secondary tables show customers or connected_accounts
                    const result = this.formatSecondaryRow(item, persona);
                    console.log(`🔧 formatSecondaryRow result for ${persona}:`, result);
                    return result;
                }
            }

            formatPaymentRow(item, persona) {
                // All personas use payments, but show different metadata in columns 4-5
                const baseColumns = `
                    <td>${item.id}</td>
                    <td>${this.formatCurrency(item.amount)}</td>
                    <td><span class="status-badge status-${item.status}">${item.status}</span></td>
                `;

                switch (persona) {
                    case 'modaic':
                        return baseColumns + `
                            <td>${item.currency?.toUpperCase()}</td>
                            <td>${item.customer}</td>
                        `;
                    case 'mindora':
                        return baseColumns + `
                            <td>${item.metadata?.course_id || 'Course'}</td>
                            <td>${item.customer}</td>
                        `;
                    case 'keynest':
                        return baseColumns + `
                            <td>${item.metadata?.property_id || 'Property'}</td>
                            <td>${item.customer}</td>
                        `;
                    case 'pulseon':
                        return baseColumns + `
                            <td>${item.metadata?.plan_type || 'Plan'}</td>
                            <td>${item.customer}</td>
                        `;
                    case 'fluxly':
                        return baseColumns + `
                            <td>${item.metadata?.content_type || 'Content'}</td>
                            <td>${item.customer}</td>
                        `;
                    case 'brightfund':
                        return baseColumns + `
                            <td>${item.metadata?.campaign_id || 'Campaign'}</td>
                            <td>${item.customer}</td>
                        `;
                    case 'procura':
                        return baseColumns + `
                            <td>${item.metadata?.purchase_order || 'PO'}</td>
                            <td>${item.customer}</td>
                        `;
                    case 'stratus':
                        return baseColumns + `
                            <td>${item.metadata?.plan_tier || 'Plan'}</td>
                            <td>${item.customer}</td>
                        `;
                    case 'forksy':
                        return baseColumns + `
                            <td>${item.metadata?.restaurant_id || 'Restaurant'}</td>
                            <td>${item.customer}</td>
                        `;
                    default:
                        return baseColumns + `
                            <td>-</td>
                            <td>${item.customer}</td>
                        `;
                }
            }

            formatSecondaryRow(item, persona) {
                switch (persona) {
                    case 'modaic':
                        // Customers
                        return `
                            <td>${item.id}</td>
                            <td>${item.email}</td>
                            <td>${item.name}</td>
                            <td>${this.formatCurrency(item.metadata?.total_spend || 0)}</td>
                            <td>${item.address?.country || 'US'}</td>
                        `;
                    case 'mindora':
                        // Connected accounts (instructors)
                        return `
                            <td>${item.id}</td>
                            <td>${item.business_profile?.name || 'Instructor'}</td>
                            <td>${item.metadata?.expertise || 'General'}</td>
                            <td>${item.metadata?.rating || '4.5'}⭐</td>
                            <td>${item.metadata?.total_students || 0}</td>
                        `;
                    case 'keynest':
                        // Connected accounts (landlords)
                        return `
                            <td>${item.id}</td>
                            <td>${item.business_profile?.name || 'Landlord'}</td>
                            <td>${item.metadata?.properties_count || 0}</td>
                            <td>${item.metadata?.years_experience || 0} years</td>
                            <td>${this.formatCurrency(item.metadata?.portfolio_value || 0)}</td>
                        `;
                    case 'pulseon':
                        // Customers (members)
                        return `
                            <td>${item.id}</td>
                            <td>${item.email}</td>
                            <td>${item.metadata?.fitness_level || 'Beginner'}</td>
                            <td>${item.metadata?.goals || 'General'}</td>
                            <td>${item.metadata?.check_ins_this_month || 0}</td>
                        `;
                    case 'fluxly':
                        // Connected accounts (creators)
                        return `
                            <td>${item.id}</td>
                            <td>${item.business_profile?.name || 'Creator'}</td>
                            <td>${item.metadata?.creator_category || 'Art'}</td>
                            <td>${item.metadata?.followers_count || 0}</td>
                            <td>${item.metadata?.content_count || 0}</td>
                        `;
                    case 'brightfund':
                        // Customers (donors)
                        return `
                            <td>${item.id}</td>
                            <td>${item.email}</td>
                            <td>${item.metadata?.donor_type || 'Individual'}</td>
                            <td>${this.formatCurrency(item.metadata?.total_donated || 0)}</td>
                            <td>${item.metadata?.donation_frequency || 'One-time'}</td>
                        `;
                    case 'procura':
                        // Customers (hospitals)
                        return `
                            <td>${item.id}</td>
                            <td>${item.name}</td>
                            <td>${item.metadata?.facility_type || 'Hospital'}</td>
                            <td>${this.formatCurrency(item.metadata?.credit_limit || 0)}</td>
                            <td>${this.formatCurrency(item.metadata?.total_spend || 0)}</td>
                        `;
                    case 'stratus':
                        // Customers (companies)
                        return `
                            <td>${item.id}</td>
                            <td>${item.name}</td>
                            <td>${item.metadata?.industry || 'Technology'}</td>
                            <td>${item.metadata?.employee_count || 0}</td>
                            <td>${this.formatCurrency(item.metadata?.total_spend || 0)}</td>
                        `;
                    case 'forksy':
                        // Connected accounts (restaurants)
                        return `
                            <td>${item.id}</td>
                            <td>${item.business_profile?.name || 'Restaurant'}</td>
                            <td>${item.metadata?.account_type || 'Restaurant'}</td>
                            <td>${item.metadata?.rating || '4.5'}⭐</td>
                            <td>${item.metadata?.total_orders || 0}</td>
                        `;
                    default:
                        return `
                            <td>${item.id}</td>
                            <td>-</td>
                        `;
                }
            }

            formatCurrency(cents) {
                return new Intl.NumberFormat('en-US', {
                    style: 'currency',
                    currency: 'USD',
                    minimumFractionDigits: 0
                }).format(cents / 100);
            }

            initializeNavbarSelectors() {
                // Initialize new persona selector UI
                this.initializePersonaSelector();
                this.setupPersonaUIEvents();
                this.populatePersonaModal();
                
                // Set initial stage
                this.currentStage = 'growth';
                this.updateStageSelection();
            }
            
            initializePersonaSelector() {
                // Set up the new persona selector interface
                this.selectedPersonaForModal = this.currentPersona;
                this.updatePersonaSelectorDisplay();
            }
            
            setupPersonaUIEvents() {
                // Persona selector button click
                const selectorBtn = document.getElementById('persona-selector-btn');
                const popover = document.getElementById('persona-popover');
                const dropdownArrow = document.getElementById('dropdown-arrow');
                
                selectorBtn.addEventListener('click', (e) => {
                    e.stopPropagation();
                    const isOpen = popover.classList.contains('show');
                    if (isOpen) {
                        this.closePopover();
                    } else {
                        this.openPopover();
                    }
                });
                
                // Close popover when clicking outside
                document.addEventListener('click', (e) => {
                    if (!selectorBtn.contains(e.target) && !popover.contains(e.target)) {
                        this.closePopover();
                    }
                });
                
                // Change persona button
                const changeBtn = document.getElementById('change-persona-btn');
                changeBtn.addEventListener('click', (e) => {
                    e.stopPropagation();
                    this.closePopover();
                    this.openPersonaModal();
                });
                
                // Stage options
                const stageOptions = document.querySelectorAll('.stage-option');
                stageOptions.forEach(option => {
                    option.addEventListener('click', (e) => {
                        const newStage = e.target.dataset.stage;
                        this.currentStage = newStage;
                        this.updateStageData();
                        this.updateStageSelection();
                        // Close the popover after stage selection
                        this.closePopover();
                    });
                });
                
                // Modal events
                const modal = document.getElementById('persona-modal');
                const modalDone = document.getElementById('modal-done');
                
                // Only the Done button exists after modal redesign
                modalDone.addEventListener('click', () => {
                    this.applyPersonaSelection();
                });
                
                // Close modal when clicking backdrop
                modal.addEventListener('click', (e) => {
                    if (e.target === modal) {
                        this.closePersonaModal();
                    }
                });
            }
            
            openPopover() {
                const popover = document.getElementById('persona-popover');
                const arrow = document.getElementById('dropdown-arrow');
                const button = document.getElementById('persona-selector-btn');
                
                popover.classList.add('show');
                arrow.classList.add('open');
                button.classList.add('open');
            }
            
            closePopover() {
                const popover = document.getElementById('persona-popover');
                const arrow = document.getElementById('dropdown-arrow');
                const button = document.getElementById('persona-selector-btn');
                
                popover.classList.remove('show');
                arrow.classList.remove('open');
                button.classList.remove('open');
            }
            
            openPersonaModal() {
                const modal = document.getElementById('persona-modal');
                modal.classList.add('show');
                document.body.style.overflow = 'hidden';
            }
            
            closePersonaModal() {
                const modal = document.getElementById('persona-modal');
                modal.classList.remove('show');
                document.body.style.overflow = 'auto';
                // Reset selection to current persona
                this.selectedPersonaForModal = this.currentPersona;
                this.updateModalSelection();
            }
            
            updateStageSelection() {
                const stageOptions = document.querySelectorAll('.stage-option');
                stageOptions.forEach(option => {
                    const checkElement = option.querySelector('.stage-check');
                    option.classList.remove('selected');
                    
                    if (option.dataset.stage === this.currentStage) {
                        option.classList.add('selected');
                        checkElement.textContent = '✓';
                    } else {
                        checkElement.textContent = '';
                    }
                });
            }
            
            updatePersonaSelectorDisplay() {
                console.log('🔄 updatePersonaSelectorDisplay called');
                console.log('🎭 this.currentPersona is:', this.currentPersona);
                const personas = this.dataClient.getAvailablePersonas();
                console.log('📋 Available personas:', Object.keys(personas));
                console.log('📋 All persona names:', Object.values(personas).map(p => p.name));
                const currentPersona = personas[this.currentPersona];
                console.log('👤 Current persona data:', currentPersona);
                console.log('🏷️ Persona name should be:', currentPersona?.name);
                console.log('🔍 Setting selector name to:', currentPersona?.name);
                
                if (!currentPersona) {
                    console.error('❌ No current persona found for:', this.currentPersona);
                    return;
                }
                
                // Map persona IDs to their image filenames (now they match!)
                const personaImageMap = {
                    'modaic': 'modaic',
                    'mindora': 'mindora', 
                    'keynest': 'keynest',
                    'pulseon': 'pulseon',
                    'fluxly': 'fluxly',
                    'brightfund': 'brightfund',
                    'procura': 'procura',
                    'stratus': 'stratus',
                    'forksy': 'forksy'
                };
                
                const imageFilename = personaImageMap[this.currentPersona] || this.currentPersona;
                console.log(`🎭 Persona ${this.currentPersona} maps to image: ${imageFilename}.png`);
                
                // Update main selector button
                const logo = document.getElementById('current-persona-logo');
                const name = document.getElementById('current-persona-name');
                
                // Try multiple path variations for local dev and GitHub Pages
                const possiblePaths = [
                    `/docs/assets/${imageFilename}.png`, // Local dev from project root (localhost:8080)
                    `../assets/${imageFilename}.png`,  // GitHub Pages / relative from examples/
                    `assets/${imageFilename}.png`,     // Local dev from docs root
                    `./assets/${imageFilename}.png`    // Alternative relative
                ];
                
                const logoPath = possiblePaths[0]; // Start with the first one
                console.log('🖼️ Setting logo path:', logoPath);
                console.log('🖼️ All possible paths:', possiblePaths);
                console.log('🔍 FIRST PATH SHOULD BE /docs/assets/ - is it?', possiblePaths[0]);
                logo.src = logoPath;
                logo.alt = currentPersona.name;
                
                // Add error handling for image loading
                // Add automatic fallback for different paths
                let currentPathIndex = 0;
                const tryNextPath = () => {
                    currentPathIndex++;
                    if (currentPathIndex < possiblePaths.length) {
                        const nextPath = possiblePaths[currentPathIndex];
                        console.log(`🔄 Trying fallback path ${currentPathIndex + 1}:`, nextPath);
                        logo.src = nextPath;
                    } else {
                        console.error('❌ All logo paths failed for:', this.currentPersona);
                        logo.style.display = 'none';
                    }
                };
                
                logo.onerror = () => {
                    console.error('❌ Failed to load logo:', logo.src);
                    tryNextPath();
                };
                logo.onload = () => {
                    console.log('✅ Logo loaded successfully:', logo.src);
                    logo.style.display = 'block';
                };
                name.textContent = currentPersona.name;
                
                // Update popover
                const popoverLogo = document.getElementById('popover-persona-logo');
                const popoverName = document.getElementById('popover-persona-name');
                const popoverDescription = document.getElementById('popover-persona-description');
                
                // Use the same fallback logic for popover
                const setupPopoverImage = () => {
                    let popoverPathIndex = 0;
                    const tryNextPopoverPath = () => {
                        popoverPathIndex++;
                        if (popoverPathIndex < possiblePaths.length) {
                            const nextPath = possiblePaths[popoverPathIndex];
                            console.log(`🔄 Trying popover fallback path ${popoverPathIndex + 1}:`, nextPath);
                            popoverLogo.src = nextPath;
                        } else {
                            console.error('❌ All popover logo paths failed for:', this.currentPersona);
                            popoverLogo.style.display = 'none';
                        }
                    };
                    
                    popoverLogo.onerror = () => {
                        console.error('❌ Failed to load popover logo:', popoverLogo.src);
                        tryNextPopoverPath();
                    };
                    popoverLogo.onload = () => {
                        console.log('✅ Popover logo loaded successfully:', popoverLogo.src);
                        popoverLogo.style.display = 'block';
                    };
                    
                    popoverLogo.src = possiblePaths[0];
                };
                
                setupPopoverImage();
                popoverLogo.alt = currentPersona.name;
                console.log('📝 Setting popover name to:', currentPersona.name);
                popoverName.textContent = currentPersona.name;
                popoverDescription.textContent = currentPersona.description;
                console.log('✅ Popover name set to:', popoverName.textContent);
            }
            

            
            populatePersonaModal() {
                console.log('🎭 populatePersonaModal called');
                const personas = this.dataClient.getAvailablePersonas();
                const list = document.getElementById('personas-list');
                
                console.log('🎭 Found personas for modal:', Object.keys(personas));
                list.innerHTML = '';
                
                // Use the same persona image mapping
                const personaImageMap = {
                    'modaic': 'modaic',
                    'mindora': 'mindora', 
                    'keynest': 'keynest',
                    'pulseon': 'pulseon',
                    'fluxly': 'fluxly',
                    'brightfund': 'brightfund',
                    'procura': 'procura',
                    'stratus': 'stratus',
                    'forksy': 'forksy'
                };
                
                Object.entries(personas).forEach(([id, persona]) => {
                    console.log(`🎭 Processing persona ${id}:`, persona);
                    const option = document.createElement('div');
                    option.className = 'persona-option';
                    option.dataset.personaId = id;
                    
                    if (id === this.currentPersona) {
                        option.classList.add('selected');
                    }
                    
                    const modalImageFilename = personaImageMap[id] || id;
                    
                    // Create persona option with fallback image loading
                    option.innerHTML = `
                        <img class="persona-option-logo" alt="${persona.name}">
                        <div class="persona-option-name">${persona.name}</div>
                    `;
                    
                    // Setup image fallback for modal option
                    const modalImg = option.querySelector('.persona-option-logo');
                    const modalPossiblePaths = [
                        `/docs/assets/${modalImageFilename}.png`,     // Local dev from project root (localhost:8080)
                        `../assets/${modalImageFilename}.png`,        // GitHub Pages / relative from examples/
                        `assets/${modalImageFilename}.png`,           // Local dev from docs root
                        `./assets/${modalImageFilename}.png`          // Alternative relative
                    ];
                    
                    let modalPathIndex = 0;
                    const tryNextModalPath = () => {
                        modalPathIndex++;
                        if (modalPathIndex < modalPossiblePaths.length) {
                            const nextPath = modalPossiblePaths[modalPathIndex];
                            console.log(`🔄 Trying modal fallback path ${modalPathIndex + 1} for ${id}:`, nextPath);
                            modalImg.src = nextPath;
                        } else {
                            console.error(`❌ All modal logo paths failed for ${id}`);
                            modalImg.style.display = 'none';
                        }
                    };
                    
                    modalImg.onerror = () => {
                        console.error('❌ Failed to load modal logo:', modalImg.src);
                        tryNextModalPath();
                    };
                    modalImg.onload = () => {
                        console.log('✅ Modal logo loaded successfully:', modalImg.src);
                    };
                    
                    console.log(`🔍 MODAL: First path for ${id} (${modalImageFilename}) should be /docs/assets/ - is it?`, modalPossiblePaths[0]);
                    modalImg.src = modalPossiblePaths[0];
                    
                    option.addEventListener('click', () => {
                        console.log('🎯 Persona option clicked:', id);
                        // Remove selected from all options
                        list.querySelectorAll('.persona-option').forEach(opt => {
                            opt.classList.remove('selected');
                        });
                        // Add selected to clicked option
                        option.classList.add('selected');
                        this.selectedPersonaForModal = id;
                        console.log('✅ Selected persona for modal set to:', this.selectedPersonaForModal);
                        
                        // Update details panel
                        this.updatePersonaDetails(persona);
                    });
                    
                    list.appendChild(option);
                });
                
                // Initialize details panel with current persona
                const currentPersona = personas[this.selectedPersonaForModal || this.currentPersona];
                if (currentPersona) {
                    this.updatePersonaDetails(currentPersona);
                }
            }
            
            updatePersonaDetails(persona) {
                const detailsPanel = document.getElementById('persona-details');
                
                detailsPanel.innerHTML = `
                    <div class="persona-details-content">
                        <h3 class="details-description">${persona.description}</h3>
                        
                        <div class="stripe-products-section">
                            <h4 class="stripe-products-title">Stripe products used</h4>
                            <ul class="stripe-products-list">
                                ${persona.stripe_products.map(product => `<li>• ${product}</li>`).join('')}
                            </ul>
                        </div>
                    </div>
                `;
            }
            
            updateModalSelection() {
                const list = document.getElementById('personas-list');
                list.querySelectorAll('.persona-option').forEach(option => {
                    option.classList.remove('selected');
                    if (option.dataset.personaId === this.selectedPersonaForModal) {
                        option.classList.add('selected');
                    }
                });
            }
            
            async applyPersonaSelection() {
                console.log('🎯 Apply persona selection called');
                console.log('🎭 Selected persona for modal:', this.selectedPersonaForModal);
                console.log('🎭 Current persona:', this.currentPersona);
                
                if (this.selectedPersonaForModal && this.selectedPersonaForModal !== this.currentPersona) {
                    console.log('✅ Switching to new persona:', this.selectedPersonaForModal);
                    await this.switchPersona(this.selectedPersonaForModal);
                } else {
                    console.log('❌ No persona change needed or no selection made');
                }
                this.closePersonaModal();
            }
            
            async switchPersona(personaId) {
                if (personaId === this.currentPersona) return;
                
                console.log('🔄 switchPersona called with:', personaId);
                console.log('🎭 Previous persona:', this.currentPersona);
                
                try {
                    await this.dataClient.switchPersona(personaId);
                    this.currentPersona = personaId;
                    console.log('✅ Data client switched, updating UI to:', personaId);
                    
                    // Visual indicator removed - selector working correctly
                    
                    this.updatePersonaSelectorDisplay();
                    this.updateDashboard();
                    this.animateSwitch();
                    console.log('🎉 Persona switch complete!');
                } catch (error) {
                    console.error('❌ Failed to switch persona:', error);
                }
            }
            

            
            updateStageData() {
                console.log(`Stage changed to: ${this.currentStage}`);
                
                // Update the data client with new stage
                this.currentData = this.dataClient.updateStage(this.currentStage);
                
                // Refresh the dashboard with stage-appropriate data
                this.updateDashboard();
            }

            onPersonaSwitch(personaId) {
                // This is where designers can add custom logic when personas change
                console.log(`Dashboard switched to ${personaId}`);
                
                // Example: You could trigger custom animations, update charts, etc.
                this.animateSwitch();
            }

            animateSwitch() {
                // Simple animation to show the switch happened
                const content = document.getElementById('dashboard-content');
                content.style.opacity = '0.5';
                setTimeout(() => {
                    content.style.opacity = '1';
                }, 200);
            }

            showError(message) {
                document.getElementById('loading-state').innerHTML = `
                    <h3>Error</h3>
                    <p>${message}</p>
                `;
            }
        }

        // Initialize the dashboard when page loads
        document.addEventListener('DOMContentLoaded', () => {
            new DashboardPrototype();
        });
    </script>
</body>
</html>
